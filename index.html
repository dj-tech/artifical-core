<!DOCTYPE html>
<html>
<head>
<title>PinW</title>
<script src="https://rawgit.com/aFarkas/html5shiv/gh-pages/dist/html5shiv.min.js"></script>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="/path/to/d3-transform.js"></script>
<script>
d3.select('svg').selectAll('g')
    .data([{ size: 5 }, { size: 10 }])
  .enter().append('g')
    .attr('transform', function(d, i) {
      return "translate(20," + d.size * 10 + ") rotate (40) scale(" + ( d.size + 2 ) + ")");
    });
 var transform = d3.svg.transform()
    .translate(function(d) { return [20, d.size * 10] })
    .rotate(40)
    .scale(function(d) { return d.size + 2 });

var svg = d3.select('svg.example1').selectAll('g')
    .data([{ size: 5 }, { size: 10 }])
    .enter()
    .append('g')
    .attr('transform', transform);
</script>
<svg>
  <g transform="translate(20,50) rotate(40) scale(7)"></g>
  <g transform="translate(20,100) rotate(40) scale(12)"></g>
</svg>
<link rel="stylesheet" href="normalize.css">
<style>
  /*! suit-test v0.1.0 | MIT License | github.com/suitcss */
  .Test {
    background: #fff;
    counter-reset: test-describe;
  }
  .Test-describe:before {
    content: counter(test-describe);
    counter-increment: test-describe;
  }
  .Test-describe {
    counter-reset: test-it;
  }
  .Test-it:before {
    content: counter(test-describe) "." counter(test-it);
    counter-increment: test-it;
  }
  .Test-title {
    font-size: 2em;
    font-family: sans-serif;
    padding: 20px;
    margin: 20px 0;
    background: #eee;
    color: #999;
  }
  .Test-describe,
  .Test-it {
    background: #eee;
    border-left: 5px solid #666;
    color: #666;
    font-family: sans-serif;
    font-weight: bold;
    margin: 20px 0;
    padding: 0.75em 20px;
  }
  .Test-describe {
    font-size: 1.5em;
    margin: 60px 0 20px;
  }
  .Test-describe:before,
  .Test-it:before {
    color: #999;
    display: inline-block;
    margin-right: 10px;
    min-width: 30px;
    text-transform: uppercase;
  }
  /* Custom helpers */
  /**
   * Test whether the body's margin has been removed
   */
  body {
    background: red;
  }
  /**
   * Highlight the bounds of direct children of a test block
   */
  .Test-run--highlightEl > * {
    outline: 1px solid #ADD8E6;
  }
</style>

<div class="Test">
  .

  <h1 class="Test-title"><a href="https://github.com/necolas/normalize.css">Normalize.css</a>: UI tests</h1>

  <h2 class="Test-describe"><code>html</code></h2>
  <h3 class="Test-it">should have sans-serif font family (opinionated)</h3>
  <div class="Test-run">
    abcdefghijklmnopqrstuvwxyz
  </div>
  <h3 class="Test-it">should have a line height of 1.15</h3>
  <div class="Test-run">
    abcdefghijklmnopqrstuvwxyz
  </div>

  <h2 class="Test-describe"><code>body</code></h2>
  <h3 class="Test-it">should have no margin (opinionated)</h3>
  <div class="Test-run">
    (there should be no red background visible on this page)
  </div>

  <h2 class="Test-describe">
    <code>article</code>, <code>aside</code>, <code>details</code>,
    <code>figure</code>, <code>figcaption</code>, <code>footer</code>,
    <code>header</code>, <code>main</code>,
    <code>menu</code>, <code>nav</code>, <code>section</code>,
    <code>summary</code>
  </h2>
  <h3 class="Test-it">should render as block</h3>
  <div class="Test-run Test-run--highlightEl">
    <article>article</article>
    <aside>aside</aside>
    <details>
      <summary>summary</summary>
      details
    </details>
    <figure>
      figure
      <figcaption>figcaption</figcaption>
    </figure>
    <footer>footer</footer>
    <header>header</header>
    <main>main</main>
    <menu><li>menu</li></menu>
    <nav>nav</nav>
    <section>section</section>
  </div>

  <h2 class="Test-describe"><code>audio</code>, <code>canvas</code>, <code>progress</code>, <code>video</code></h2>
  <h3 class="Test-it">should render as inline-block and baseline-aligned</h3>
  <div class="Test-run Test-run--highlightEl">
    <audio controls>audio</audio>
    <canvas>canvas</canvas>
    <progress>progress</progress>
    <video controls>video</video>
  </div>

  <h2 class="Test-describe"><code>audio:not([controls])</code>, <code>template</code>, <code>[hidden]</code></h2>
  <h3 class="Test-it">should not display</h3>
  <div class="Test-run Test-run--highlightEl">
    <audio>audio</audio>
    <template>
      <h1>{{title}}</h1>
      <content></content>
    </template>
    <p hidden>This should be hidden</p>
  </div>

  <h2 class="Test-describe"><code>a</code></h2>
  <h3 class="Test-it">should have a transparent background when active</h3>
  <div class="Test-run">
    <a href="#non">dummy anchor</a>
  </div>
  <h3 class="Test-it">should not skip underlines</h3>
  <div class="Test-run">
    <a href="#non">quip and jig</a>
  </div>
  <h3 class="Test-it">should not have a focus outline when both focused and hovered (opinionated)</h3>
  <div class="Test-run">
    <a href="#non">dummy anchor</a>
  </div>

  <h2 class="Test-describe"><code>abbr[title]</code></h2>
  <h3 class="Test-it">should have a dotted underline with a solid underline as a fallback</h3>
  <div class="Test-run">
    <abbr title="abbreviation">abbr</abbr>
  </div>

  <h2 class="Test-describe"><code>b</code>, <code>strong</code></h2>
  <h3 class="Test-it">should have bolder font-weight</h3>
  <div class="Test-run">
    <b>b</b>
    <strong>strong</strong>
  </div>

  <h2 class="Test-describe"><code>dfn</code></h2>
  <h3 class="Test-it">should have italic font-style</h3>
  <div class="Test-run">
    <dfn>dfn</dfn>
  </div>

  <h2 class="Test-describe"><code>h1</code></h2>
  <h3 class="Test-it">should not change size within an <code>article</code></h3>
  <div class="Test-run">
    <h1>Heading (control)</h1>
    <article>
      <h1>Heading (in article)</h1>
    </article>
  </div>
  <h3 class="Test-it">should not change size within a <code>section</code></h3>
  <div class="Test-run">
    <h1>Heading (control)</h1>
    <section>
      <h1>Heading (in section)</h1>
    </section>
  </div>

  <h2 class="Test-describe"><code>mark</code></h2>
  <h3 class="Test-it">should have a yellow background</h3>
  <div class="Test-run">
    <mark>mark</mark>
  </div>

  <h2 class="Test-describe"><code>small</code></h2>
  <h3 class="Test-it">should render equally small in all browsers</h3>
  <div class="Test-run">
    control. <small>small.</small>
  </div>

  <h2 class="Test-describe"><code>sub</code> and <code>sup</code></h2>
  <h3 class="Test-it">should not affect a line's visual line-height</h3>
  <div class="Test-run Test-run--highlightEl">
    <p>control.</p>
    <p>control. <sub>sub.</sub></p>
    <p>control. <sup>sup.</sup></p>
  </div>

  <h2 class="Test-describe"><code>img</code></h2>
  <h3 class="Test-it">should not have a border when wrapped in an anchor</h3>
  <div class="Test-run">
    <a href="#non">
      <!-- scaled-up 1px image -->
      <img style="background-color:#ADD8E6" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" width="100" height="100">
    </a>
  </div>

  <h2 class="Test-describe"><code>svg</code></h2>
  <h3 class="Test-it">should not overflow</h3>
  <div class="Test-run Test-run--highlightEl">
    <svg width="100px" height="100px">
      <circle cx="100" cy="100" r="100" fill="#ADD8E6" />
    </svg>
  </div>

  <h2 class="Test-describe"><code>code</code>, <code>kbd</code>, <code>pre</code>, <code>samp</code></h2>
  <h3 class="Test-it">should render text at the same absolute size as normal text</h3>
  <div class="Test-run">
    <span>span: abcdefghijklmnopqrstuvwxyz.</span><br>
    <code>code: abcdefghijklmnopqrstuvwxyz.</code><br>
    <kbd>kbd: abcdefghijklmnopqrstuvwxyz.</kbd><br>
    <samp>samp: abcdefghijklmnopqrstuvwxyz.</samp>
    <pre>pre: abcdefghijklmnopqrstuvwxyz.</pre>
  </div>

  <h2 class="Test-describe"><code>figure</code></h2>
  <h3 class="Test-it">should have margins</h3>
  <div class="Test-run" style="outline:1px solid #ADD8E6; overflow:hidden;">
    <figure>
      <img style="background-color:#ADD8E6" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" width="400" height="200">
    </figure>
  </div>

  <h2 class="Test-describe"><code>hr</code></h2>
  <h3 class="Test-it">should have a <code>content-box</code> box model</h3>
  <div class="Test-run" style="">
    <hr style="height:2px; border:solid #ADD8E6; border-width:2px 0;">
  </div>

  <h2 class="Test-describe"><code>button</code>, <code>input</code>, <code>optgroup</code>, <code>select</code>, <code>textarea</code></h2>
  <h3 class="Test-it">should inherit <code>font</code> from ancestor</h3>
  <div class="Test-run" style="font:bold italic 20px/1 serif;">
    <button>button</button><br>
    <input value="input"><br>
    <select style="border:1px solid #999;">
      <optgroup label="optgroup">
        <option>option</option>
      </optgroup>
      <option>option</option>
    </select><br>
    <textarea>textarea</textarea>
  </div>
  <h3 class="Test-it">should not have margins</h3>
  <div class="Test-run" id="form-collection-margins">
    <style>
      #form-collection-margins {
        outline: 1px solid #ADD8E6;
        overflow: hidden;
      }
      #form-collection-margins button,
      #form-collection-margins input,
      #form-collection-margins select,
      #form-collection-margins textarea {
        display: block;
      }
    </style>
    <button>button</button>
    <input value="input">
    <select style="border:1px solid #999;">
      <optgroup label="optgroup">
        <option>option</option>
      </optgroup>
      <option>option</option>
    </select>
    <textarea>textarea</textarea>
  </div>

  <h2 class="Test-describe"><code>button</code></h2>
  <h3 class="Test-it">should have visible overflow</h3>
  <div class="Test-run" id="button-overflow">
    <style>
      #button-overflow button:after {
        content: "";
        background: #ADD8E6;
        display: inline-block;
        height: 10px;
        position:relative;
        right: -20px;
        width: 10px;
      }
    </style>
    <button>abcdefghijklmnopqrstuvwxyz</button>
  </div>

  <h2 class="Test-describe"><code>button</code>, <code>select</code></h2>
  <h3 class="Test-it">should not inherit <code>text-transform</code></h3>
  <div class="Test-run" style="text-transform:uppercase">
    <button>button</button>
    <select><option>option</option></select>
  </div>

  <h2 class="Test-describe"><code>button</code> and button-style <code>input</code></h2>
  <h3 class="Test-it">should be styleable</h3>
  <div class="Test-run" id="button-like-style">
    <style>
      #button-like-style button,
      #button-like-style input {
        background: #ADD8E6;
        border: 2px solid black;
        border-radius: 2px;
        padding: 5px;
      }
    </style>
    <p><button>button</button></p>
    <p><input type="image" src="//placehold.it/90x24" alt="input (image)"></p>
    <p><input type="button" value="input (button)"></p>
    <p><input type="file" value="input (file)"></p>
    <p><input type="reset" value="input (reset)"></p>
    <p><input type="submit" value="input (submit)"></p>
  </div>

  <h2 class="Test-describe">disabled <code>button</code> and <code>input</code></h2>
  <h3 class="Test-it">should have <code>default</code> cursor style</h3>
  <div class="Test-run">
    <p><button disabled>button</button></p>
    <p><input disabled type="button" value="input (button)"></p>
    <p><input disabled type="reset" value="input (reset)"></p>
    <p><input disabled type="submit" value="input (submit)"></p>
  </div>

  <h2 class="Test-describe"><code>button</code>, <code>input</code></h2>
  <h3 class="Test-it">should not have extra inner padding in Firefox</h3>
  <div class="Test-run" id="button-input-padding">
    <style>
      #button-input-padding button,
      #button-input-padding input {
        border: 0;
        padding: 0;
        outline: 1px solid #ADD8E6;
      }
    </style>
    <p><button>button</button></p>
    <p><input type="button" value="input (button)"></p>
    <p><input type="reset" value="input (reset)"></p>
    <p><input type="submit" value="input (submit)"></p>
  </div>

  <h2 class="Test-describe"><code>fieldset</code></h2>
  <h3 class="Test-it">should have consistent border, padding, and margin</h3>
  <div class="Test-run">
    <fieldset>
      <div style="width:100%; height:100px; background:#ADD8E6;"></div>
    </fieldset>
  </div>

  <h2 class="Test-describe"><code>legend</code></h2>
  <h3 class="Test-it">should inherit color</h3>
  <div class="Test-run" style="color:#ADD8E6;">
    <fieldset>
      <legend>legend</legend>
    </fieldset>
  </div>
  <h3 class="Test-it">should not have padding</h3>
  <div class="Test-run">
    <fieldset>
      <legend>legend</legend>
    </fieldset>
  </div>
  <h3 class="Test-it">should wrap text</h3>
  <div class="Test-run">
    <fieldset>
      <legend>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et me.</legend>
    </fieldset>
  </div>

  <h2 class="Test-describe"><code>textarea</code></h2>
  <h3 class="Test-it">should not have a scrollbar unless overflowing</h3>
  <div class="Test-run">
    <textarea>textarea</textarea>
  </div>

  <h2 class="Test-describe"><code>[type="checkbox"]</code>, <code>[type="radio"]</code></h2>
  <h3 class="Test-it">should have a <code>border-box</code> box model</h3>
  <div class="Test-run Test-run--highlightEl" id="radio-box-model">
    <style>
      #radio-box-model {
        width: 200px;
        border: 1px solid red;
      }
      #radio-box-model input {
        width: 100%;
        border: 5px solid #ADD8E6;
        display: block;
        position: relative;
      }
    </style>
    <input type="checkbox">
    <input type="radio" name="rad">
  </div>
  <h3 class="Test-it">should not have padding</h3>
  <div class="Test-run Test-run--highlightEl">
    <input type="checkbox">
    <input type="radio" name="rad">
  </div>

  <h2 class="Test-describe"><code>[type="number"]</code></h2>
  <h3 class="Test-it">should display a default cursor for the decrement button's click target in Chrome</h3>
  <div class="Test-run">
    <input style="height:50px; font-size:15px;" type="number" id="in" min="0" max="10" value="5">
  </div>

  <h2 class="Test-describe"><code>[type="search"]</code></h2>
  <h3 class="Test-it">should be styleable</h3>
  <div class="Test-run">
    <input type="search" style="border:1px solid #ADD8E6; padding:10px; width:200px;">
  </div>
  <h3 class="Test-it">should not have a cancel button in Safari or Chrome</h3>
  <div class="Test-run">
    <input type="search" value="search">
  </div>
  <h3 class="Test-it">should reference inherited color</h3>
  <div class="Test-run">
    <input type="text" placeholder="Text goes here" style="background-color: black; color: orange;">
  </div>

</div>
</head>
<body>
<html manifest="demo.appcache">
<script>
<script src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>
<script src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/pouchdb/latest/pouchdb.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/processing.js/1.4.1/processing-api.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.9.2/coffee-script.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.0/angular.min.js"></script>
<script src="https://code.jquery.com/jquery.min.js"></script>
<link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet" type="text/css" />
<script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/mootools/1.5.0/mootools-nocompat-yui-compressed.js"></script>
<script src="https://code.jquery.com/jquery-compat-3.0.0-alpha1.js"></script>
<meta name="description" content="[use bin ubuntu acces of acaunt google]">
<script src="https://code.jquery.com/jquery-compat-git.js"></script>
<script src="https://github.com/AlgoLab/pinw/blob/master/public/js/index.js"></script>
<script src="https://cdn.firebase.com/js/client/1.1.2/firebase.js"></script>
<script src="path/to/angular.js"></script>
<script src="path/to/angular-animate.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular-resource.min.js">
</script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular-route.min.js">
</script>
<script src="https://cdn.firebase.com/js/client/2.0.4/firebase.js"></script>
<script src="https://cdn.firebase.com/libs/angularfire/0.9.0/angularfire.min.js"></script>
<script src="https://github.com/jasmine/jasmine/blob/master/src/core/base.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
<script src="https://rawgit.com/angular/bower-angular/master/angular.min.js"></script>
</script>

<input type="file" id="input">

<h1>This is a Heading</h1>
<script src="https://www.gstatic.com/firebasejs/3.1.0/firebase.js"></script>
<script>
  // Initialize Firebase
  // TODO: Replace with your project's customized code snippet
  var config = {
    apiKey: "apiKey",
    authDomain: "projectId.firebaseapp.com",
    databaseURL: "https://pinwcore.firebaseio.com",
    storageBucket: "bucket.appspot.com",
  };
  firebase.initializeApp(config);
  function writeUserData(structur, gene, number) {
  firebase.database().ref('structur/' + gene).set({
    username: gene,
    email: number
  });
  firebase.auth().createUserWithEmailAndPassword(email, password).catch(function(error) {
  // Handle Errors here.
  var errorCode = error.code;
  var errorMessage = error.message;
  // ...
  });
}
</script>
<p>This is a paragraph.</p>

<script>
  firebase.auth().signInWithEmailAndPassword(email, password).catch(function(error) {
  // Handle Errors here.
  var errorCode = error.code;
  var errorMessage = error.message;
  // ...
});
</script>
<button> start script
<script>
  // Creates the provider object.
  var provider = new firebase.auth.FacebookAuthProvider();
  // You can add additional scopes to the provider:
  provider.addScope('email');
  provider.addScope('user_friends');
  // Link with popup:
  user.linkWithPopup(provider).then(function(result) {
  // The firebase.User instance:
  var user = result.user;
  // The Facebook firebase.auth.AuthCredential containing the Facebook
  // access token:
  var credential = result.credential;
  }, function(error) {
  // An error happened.
});
</script>

<script>
  firebase.database().goOnline();
</script>

<script>
  // Find all dinosaurs whose names come before Pterodactyl lexicographically.
  var ref = firebase.database().ref("dinosaurs");
  ref.orderByKey().endAt("pterodactyl").on("child_added", function(snapshot) {
  console.log(snapshot.key);
});
</script>
</button>

<script>
var var2;


if (false ? 1 * 60 : null){
  var2 = 'pinW';
}else if (false){
}
var2 = (typeof var2 == 'number' ? var2 : 0) + 1;

class MessageBusSource {

   initChanell (chanell: string , runInZone: boolean);
  void
   
   attachToZone (chanell: string) : void
   
   from (chanell: string) : EventEmitter
   
}

class ResponseType {

   Basic
   
   Cors
   
   Defualt
   
   Error
   
   Opaque
   
}

(function (app) {

 app.AppComponent =
 
  ng.core.Component ({ 
  
   selector: 'my-app'
   
   template: '<h1> PinW </h1>'
   
  })
  
  .Class({
  
   constructor: function() {}
   
  });

}) (window.app || (window.app = {}))
</script>

<script>
document.getElementById("demo").innerHTML = "Hello pinW!";
var x = Math.PI;            // Returns PI
var y = Math.sqrt(16);      // Returns the square root of 16
var d = new Date();
var d = new Date(milliseconds);
var d = new Date(dateString);
var d = new Date(year, month, day, hours, minutes, seconds, milliseconds);
var pinW= ["ssh", "ip", "id", "nome"];
x.push("operation = ...");
document.getElementById("myH1").style.color = "red";
</script>

<Div>
      <label> Nome: </ label>
      <input  di tipo = "text"  modello ng = "yourName"  segnaposto = "Inserire un nome qui" >
      <Hr>
      <h1> Hello {{YourName}} ! </ h1>
</ Div>


<tabs>
    <pane title="Localization">
      <span>Date: {{ '2012-04-01' | date:'fullDate' }}</span><br>
      <span>Currency: {{ 123456 | currency }}</span><br>
      <span>Number: {{ 98765.4321 | number }}</span><br>
    </pane>
    <pane title="Pluralization">
      <div ng-controller="BeerCounter">
        <div ng-repeat="beerCount in beers">
          <ng-pluralize count="beerCount" when="beerForms"></ng-pluralize>
</tabs>

</body>

<body class="tetris-body example-base">
  <div>
    <canvas id="canvas0" width="250" height="500"></canvas>
    <canvas id="canvas1" width="250" height="500"></canvas>
  </div>
  <input type="button" id="restartButton" value="Restart Game" class="hide" />
  <div id="gameInProgress">Game is in progress.  You will automatically join if either player leaves.</div>


<script>

  var canvas = $("#canvas0").get(0);
  if (!canvas || !canvas.getContext || !canvas.getContext('2d'))
    alert("You must use a browser that supports HTML5 Canvas to run this demo.");

  function start() {
    var tetrisRef = new Firebase('https://rw7gpb2jisy.firebaseio-demo.com/');
    var tetrisController = new Tetris.Controller(tetrisRef);
  }

  var Tetris = { };

  /**
   * Various constants related to board size / drawing.
   */
  Tetris.BOARD_WIDTH = 10; // (in "blocks", not pixels)
  Tetris.BOARD_HEIGHT = 20;

  Tetris.BLOCK_SIZE_PIXELS = 25;
  Tetris.BOARD_HEIGHT_PIXELS = Tetris.BOARD_HEIGHT * Tetris.BLOCK_SIZE_PIXELS;
  Tetris.BOARD_WIDTH_PIXELS = Tetris.BOARD_WIDTH * Tetris.BLOCK_SIZE_PIXELS;

  Tetris.BLOCK_BORDER_COLOR = "#484848";
  Tetris.BLOCK_COLORS = { 'X': 'black', 'b': 'cyan', 'B': 'blue', 'O': 'orange',
                          'Y': 'yellow', 'G': 'green', 'P': '#9370D8', 'R': 'red' };

  Tetris.GRAVITY_DELAY = 300; // 300ms

  Tetris.EMPTY_LINE  = "          ";
  Tetris.FILLED_LINE = "XXXXXXXXXX";
  Tetris.COMPLETE_LINE_PATTERN = /[^ ]{10}/;

  // Pieces.  (Indexed by piece rotation (0-3), row (0-3), piece number (0-6))
  Tetris.PIECES = [];
  for (var i = 0; i < 4; i++) { Tetris.PIECES[i] = []; }
  Tetris.PIECES[0][0] = [ "    ",   "    ",   "    ",   "    ",   "    ",   "    ",   "    " ];
  Tetris.PIECES[0][1] = [ "    ",   "B   ",   "  O ",   " YY ",   " GG ",   " P  ",   "RR  " ];
  Tetris.PIECES[0][2] = [ "bbbb",   "BBB ",   "OOO ",   " YY ",   "GG  ",   "PPP ",   " RR " ];
  Tetris.PIECES[0][3] = [ "    ",   "    ",   "    ",   "    ",   "    ",   "    ",   "    " ];
  Tetris.PIECES[1][0] = [ " b  ",   "    ",   "    ",   "    ",   "    ",   "    ",   "  R " ];
  Tetris.PIECES[1][1] = [ " b  ",   " B  ",   "OO  ",   " YY ",   " G  ",   " P  ",   " RR " ];
  Tetris.PIECES[1][2] = [ " b  ",   " B  ",   " O  ",   " YY ",   " GG ",   " PP ",   " R  " ];
  Tetris.PIECES[1][3] = [ " b  ",   "BB  ",   " O  ",   "    ",   "  G ",   " P  ",   "    " ];
  Tetris.PIECES[2][0] = [ "    ",   "    ",   "    ",   "    ",   "    ",   "    ",   "    " ];
  Tetris.PIECES[2][1] = [ "    ",   "    ",   "    ",   " YY ",   " GG ",   "    ",   "RR  " ];
  Tetris.PIECES[2][2] = [ "bbbb",   "BBB ",   "OOO ",   " YY ",   "GG  ",   "PPP ",   " RR " ];
  Tetris.PIECES[2][3] = [ "    ",   "  B ",   "O   ",   "    ",   "    ",   " P  ",   "    " ];
  Tetris.PIECES[3][0] = [ " b  ",   "    ",   "    ",   "    ",   "    ",   "    ",   "  R " ];
  Tetris.PIECES[3][1] = [ " b  ",   " BB ",   " O  ",   " YY ",   " G  ",   " P  ",   " RR " ];
  Tetris.PIECES[3][2] = [ " b  ",   " B  ",   " O  ",   " YY ",   " GG ",   "PP  ",   " R  " ];
  Tetris.PIECES[3][3] = [ " b  ",   " B  ",   " OO ",   "    ",   "  G ",   " P  ",   "    " ];



  /**
   * Stores the state of a tetris board and handles drawing it.
   */
  Tetris.Board = function (canvas, playerRef) {
    this.context = canvas.getContext('2d');
    this.playerRef = playerRef;
    this.snapshot = null;
    this.isMyBoard = false;

    // Listen for changes to our board.
    var self = this;
    playerRef.on('value', function(snapshot) {
      self.snapshot = snapshot;
      self.draw();
    });
  };


  /**
   * Draws the contents of the board as well as the current piece.
   */
  Tetris.Board.prototype.draw = function () {
    // Clear canvas.
    this.context.clearRect(0, 0, Tetris.BOARD_WIDTH_PIXELS, Tetris.BOARD_HEIGHT_PIXELS);

    // Iterate over columns / rows in board data and draw each non-empty block.
    for (var x = 0; x < Tetris.BOARD_WIDTH; x++) {
      for (var y = 0; y < Tetris.BOARD_HEIGHT; y++) {
        var colorValue = this.getBlockVal(x, y);
        if (colorValue != ' ') {
          // Calculate block position and draw a correctly-colored square.
          var left = x * Tetris.BLOCK_SIZE_PIXELS;
          var top = y * Tetris.BLOCK_SIZE_PIXELS;
          this.context.fillStyle = Tetris.BLOCK_COLORS[colorValue];
          this.context.fillRect(left, top, Tetris.BLOCK_SIZE_PIXELS, Tetris.BLOCK_SIZE_PIXELS);
          this.context.lineWidth = 1;
          this.context.strokeStyle = Tetris.BLOCK_BORDER_COLOR;
          this.context.strokeRect(left, top, Tetris.BLOCK_SIZE_PIXELS, Tetris.BLOCK_SIZE_PIXELS);
        }
      }
    }

    // If there's a falling piece, draw it.
    if (this.snapshot !== null && this.snapshot.hasChild('piece')) {
      var piece = Tetris.Piece.fromSnapshot(this.snapshot.child('piece'));
      this.drawPiece(piece);
    }

    // If this isn't my board, dim it out with a 25% opacity black rectangle.
    if (!this.isMyBoard) {
      this.context.fillStyle = "rgba(0, 0, 0, 0.25)";
      this.context.fillRect(0, 0, Tetris.BOARD_WIDTH_PIXELS, Tetris.BOARD_HEIGHT_PIXELS);
    }
  };


  /**
   * Draw the currently falling piece.
   */
  Tetris.Board.prototype.drawPiece = function (piece) {
    var self = this;
    this.forEachBlockOfPiece(piece,
      function (x, y, colorValue) {
        var left = x * Tetris.BLOCK_SIZE_PIXELS;
        var top = y * Tetris.BLOCK_SIZE_PIXELS;

        self.context.fillStyle = Tetris.BLOCK_COLORS[colorValue];
        self.context.fillRect(left, top, Tetris.BLOCK_SIZE_PIXELS, Tetris.BLOCK_SIZE_PIXELS);
        self.context.lineWidth = 1;
        self.context.strokeStyle = Tetris.BLOCK_BORDER_COLOR;
        self.context.strokeRect(left, top, Tetris.BLOCK_SIZE_PIXELS, Tetris.BLOCK_SIZE_PIXELS);
      });
  };


  /**
   * Clear the board contents.
  */
  Tetris.Board.prototype.clear = function () {
    for (var row = 0; row < Tetris.BOARD_HEIGHT; row++) {
      this.setRow(row, Tetris.EMPTY_LINE);
    }
  };


  /**
   * Given a Tetris.Piece, returns true if it has collided with the board (i.e. its current position
   * and rotation causes it to overlap blocks already on the board).
   */
  Tetris.Board.prototype.checkForPieceCollision = function (piece) {
    var collision = false;
    var self = this;
    this.forEachBlockOfPiece(piece,
      function (x, y, colorValue) {
        // NOTE: we explicitly allow y < 0 since pieces can be partially visible.
        if (x < 0 || x >= Tetris.BOARD_WIDTH || y >= Tetris.BOARD_HEIGHT) {
          collision = true;
        }
        else if (y >= 0 && self.getBlockVal(x, y) != ' ') {
          collision = true; // collision with board contents.
        }
      }, /*includeInvalid=*/ true);

    return collision;
  };


  /**
   * Given a Tetris.Piece that has landed, add it to the board contents.
   */
  Tetris.Board.prototype.addLandedPiece = function (piece) {
    var self = this;
    // We go out of our way to set an entire row at a time just so the rows show up as
    // child_added in the graphical debugger, rather than child_changed.
    var rowY = -1, rowContents = null;
    this.forEachBlockOfPiece(piece,
      function (x, y, val) {
        if (y != rowY) {
          if (rowY !== -1)
            self.setRow(rowY, rowContents);

          rowContents = self.getRow(y);
          rowY = y;
        }
        rowContents = rowContents.substring(0, x).concat(val)
          .concat(rowContents.substring(x + 1, Tetris.BOARD_WIDTH));
      });

    if (rowY !== -1)
      self.setRow(rowY, rowContents);
  };


  /**
   * Check for any completed lines (no gaps) and remove them, then return the number
   * of removed lines.
   */
  Tetris.Board.prototype.removeCompletedRows = function () {
    // Start at the bottom of the board, working up, removing completed lines.
    var copyFrom = Tetris.BOARD_HEIGHT - 1;
    var copyTo = copyFrom;

    var completedRows = 0;
    while (copyFrom >= 0) {
                var fromContents = this.getRow(copyFrom);

      // See if the line is complete (if so, we'll skip it)
      if (fromContents.match(Tetris.COMPLETE_LINE_PATTERN)) {
        copyFrom--;
        completedRows++;
      } else {
        // Copy the row down (to fill the gap from any removed rows) and continue on.
        this.setRow(copyTo, fromContents);
        copyFrom--;
        copyTo--;
      }
    }

    return completedRows;
  };


  /**
   * Generate the specified number of junk rows at the bottom of the board. Return true if the added
   * rows overflowed the board (in which case the player loses).
   */
  Tetris.Board.prototype.addJunkRows = function (numRows) {
    var overflow = false;
    // First, check if any blocks are going to overflow off the top of the screen.
    var topRowContents = this.getRow(numRows - 1);
    overflow = topRowContents.match(/[^ ]/);

    // Shift rows up to make room for the new rows.
    for (var i = 0; i < Tetris.BOARD_HEIGHT - numRows; i++) {
      var moveLineContents = this.getRow(i + numRows);
      this.setRow(i, moveLineContents);
    }

    // Fill the bottom with junk rows that are full except for a single random gap.
    var gap = Math.floor(Math.random() * Tetris.FILLED_LINE.length);
    var junkRow = Tetris.FILLED_LINE.substring(0, gap) + ' ' + Tetris.FILLED_LINE.substring(gap + 1);
    for (i = Tetris.BOARD_HEIGHT - numRows; i < Tetris.BOARD_HEIGHT; i++) {
      this.setRow(i, junkRow);
    }

    return overflow;
  };


  /**
   * Helper to enumerate the blocks that make up a particular piece.  Calls fn() for each block,
   * passing the x and y position of the block and the color value.  If includeInvalid is true, it
   * includes blocks that would fall outside the bounds of the board.
   */
  Tetris.Board.prototype.forEachBlockOfPiece = function (piece, fn, includeInvalid) {
    for (var blockY = 0; blockY < 4; blockY++) {
      for (var blockX = 0; blockX < 4; blockX++) {
        var colorValue = Tetris.PIECES[piece.rotation][blockY][piece.pieceNum].charAt(blockX);
        if (colorValue != ' ') {
          var x = piece.x + blockX, y = piece.y + blockY;
          if (includeInvalid || (x >= 0 && x < Tetris.BOARD_WIDTH && y >= 0 && y < Tetris.BOARD_HEIGHT)) {
            fn(x, y, colorValue);
          }
        }
      }
    }
  };


  Tetris.Board.prototype.getRow = function (y) {
    var row = (y < 10) ? ('0' + y) : ('' + y); // Pad row so they sort nicely in debugger. :-)

    var rowContents = this.snapshot === null ? null : this.snapshot.child('board/' + row).val();
    return rowContents || Tetris.EMPTY_LINE;
  };


  Tetris.Board.prototype.getBlockVal = function (x, y) {
    return this.getRow(y).charAt(x);
  };


  Tetris.Board.prototype.setRow = function (y, rowContents) {
    var row = (y < 10) ? ('0' + y) : ('' + y); // Pad row so they sort nicely in debugger. :-)

    if (rowContents === Tetris.EMPTY_LINE)
      rowContents = null; // delete empty lines so we get remove / added events in debugger. :-)

    this.playerRef.child('board').child(row).set(rowContents);
  };


  Tetris.Board.prototype.setBlockVal = function (x, y, val) {
    var rowContents = this.getRow(y);
    rowContents = rowContents.substring(0, x) + val + rowContents.substring(x+1);
    this.setRow(y, rowContents);
  };


  /**
   * Immutable object representing a falling piece along with its rotation and board position.
   * Has helpers for generating mutated Tetris.Piece objects (e.g. rotated or dropped).
   */
  Tetris.Piece = function (pieceNum, x, y, rotation) {
    if (arguments.length > 0) {
      this.pieceNum = pieceNum;
      this.x = x;
      this.y = y;
      this.rotation = rotation;
    } else {
      // Initialize new random piece.
      this.pieceNum = Math.floor(Math.random() * 7);
      this.x = 4; // "center" it.
      this.y = -2; // this will make the bottom line of the piece visible.
      this.rotation = 0;
    }
  };


  /**
   * Create a piece from a Firebase snapshot representing a piece.
   */
  Tetris.Piece.fromSnapshot = function (snapshot) {
    var piece = snapshot.val();
    return new Tetris.Piece(piece.pieceNum, piece.x, piece.y, piece.rotation);
  };


  /**
   * Writes the current piece data into Firebase.
   */
  Tetris.Piece.prototype.writeToFirebase = function (pieceRef) {
    pieceRef.set({pieceNum: this.pieceNum, x: this.x, y: this.y, rotation: this.rotation});
  };


  Tetris.Piece.prototype.drop = function () {
    return new Tetris.Piece(this.pieceNum, this.x, this.y + 1, this.rotation);
  };


  Tetris.Piece.prototype.rotate = function () {
    return new Tetris.Piece(this.pieceNum, this.x, this.y, (this.rotation + 1) % 4);
  };


  Tetris.Piece.prototype.moveLeft = function () {
    return new Tetris.Piece(this.pieceNum, this.x - 1, this.y, this.rotation);
  };


  Tetris.Piece.prototype.moveRight = function () {
    return new Tetris.Piece(this.pieceNum, this.x + 1, this.y, this.rotation);
  };



  /**
   * Manages joining the game, responding to keypresses, making the piece drop, etc.
   */
  Tetris.PlayingState = { Watching: 0, Joining: 1, Playing: 2 };
  Tetris.Controller = function (tetrisRef) {
    this.tetrisRef = tetrisRef;
    this.createBoards();

    this.playingState = Tetris.PlayingState.Watching;
    this.waitToJoin();
  };


  Tetris.Controller.prototype.createBoards = function () {
    this.boards = [];
    for(var i = 0; i <= 1; i++) {
      var playerRef = this.tetrisRef.child('player' + i);
      var canvas = $('#canvas' + i).get(0);
      this.boards.push(new Tetris.Board(canvas, playerRef));
    }
  };


  Tetris.Controller.prototype.waitToJoin = function() {
    var self = this;
        // Listen on 'online' location for player0 and player1.
    this.tetrisRef.child('player0/online').on('value', function(onlineSnap) {
      if (onlineSnap.val() === null && self.playingState === Tetris.PlayingState.Watching) {
        self.tryToJoin(0);
      }
    });

    this.tetrisRef.child('player1/online').on('value', function(onlineSnap) {
      if (onlineSnap.val() === null && self.playingState === Tetris.PlayingState.Watching) {
        self.tryToJoin(1);
      }
    });
  };


  /**
   * Try to join the game as the specified playerNum.
   */
  Tetris.Controller.prototype.tryToJoin = function(playerNum) {
    // Set ourselves as joining to make sure we don't try to join as both players. :-)
    this.playingState = Tetris.PlayingState.Joining;

    // Use a transaction to make sure we don't conflict with other people trying to join.
    var self = this;
    this.tetrisRef.child('player' + playerNum + '/online').transaction(function(onlineVal) {
      if (onlineVal === null) {
        return true; // Try to set online to true.
      } else {
        return; // Somebody must have beat us.  Abort the transaction.
      }
    }, function(error, committed) {
      if (committed) { // We got in!
        self.playingState = Tetris.PlayingState.Playing;
        self.startPlaying(playerNum);
      } else {
        self.playingState = Tetris.PlayingState.Watching;
      }
    });
  };


  /**
   * Once we've joined, enable controlling our player.
   */
  Tetris.Controller.prototype.startPlaying = function (playerNum) {
    this.myPlayerRef = this.tetrisRef.child('player' + playerNum);
    this.opponentPlayerRef = this.tetrisRef.child('player' + (1 - playerNum));
    this.myBoard = this.boards[playerNum];
    this.myBoard.isMyBoard = true;
    this.myBoard.draw();

    // Clear our 'online' status when we disconnect so somebody else can join.
    this.myPlayerRef.child('online').onDisconnect().remove();

    // Detect when other player pushes rows to our board.
    this.watchForExtraRows();

    // Detect when game is restarted by other player.
    this.watchForRestart();

    $('#gameInProgress').hide();

    var self = this;
    $('#restartButton').show();
    $("#restartButton").click(function () {
      self.restartGame();
    });

    this.initializePiece();
    this.enableKeyboard();
    this.resetGravity();
  };


  Tetris.Controller.prototype.initializePiece = function() {
    this.fallingPiece = null;
    var pieceRef = this.myPlayerRef.child('piece');
    var self = this;

    // Watch for changes to the current piece (and initialize it if it's null).
    pieceRef.on('value', function(snapshot) {
      if (snapshot.val() === null) {
        var newPiece = new Tetris.Piece();
        newPiece.writeToFirebase(pieceRef);
      } else {
        self.fallingPiece = Tetris.Piece.fromSnapshot(snapshot);
      }
    });
  };


  /**
   * Sets up handlers for all keyboard commands.
   */
  Tetris.Controller.prototype.enableKeyboard = function () {
    var self = this;
    $(document).on('keydown', function (evt) {
      if (self.fallingPiece === null)
        return; // piece isn't initialized yet.

      var keyCode = evt.which;
      var key = { space:32, left:37, up:38, right:39, down:40 };

      var newPiece = null;
      switch (keyCode) {
        case key.left:
          newPiece = self.fallingPiece.moveLeft();
          break;
        case key.up:
          newPiece = self.fallingPiece.rotate();
          break;
        case key.right:
          newPiece = self.fallingPiece.moveRight();
          break;
        case key.down:
          newPiece = self.fallingPiece.drop();
                 break;
        case key.space:
          // Drop as far as we can.
          var droppedPiece = self.fallingPiece;
          do {
            newPiece = droppedPiece;
            droppedPiece = droppedPiece.drop();
          } while (!self.myBoard.checkForPieceCollision(droppedPiece));
          break;
      }

      if (newPiece !== null) {
        // If the new piece position / rotation is valid, update self.fallingPiece and firebase.
        if (!self.myBoard.checkForPieceCollision(newPiece)) {
          // If the keypress moved the piece down, reset gravity.
          if (self.fallingPiece.y != newPiece.y) {
            self.resetGravity();
          }

          newPiece.writeToFirebase(self.myPlayerRef.child('piece'));
        }
        return false; // handled
      }

      return true;
    });
  };


  /**
   * Sets a timer to make the piece repeatedly drop after GRAVITY_DELAY ms.
   */
  Tetris.Controller.prototype.resetGravity = function () {
    // If there's a timer already active, clear it first.
    if (this.gravityIntervalId !== null) {
      clearInterval(this.gravityIntervalId);
    }

    var self = this;
    this.gravityIntervalId = setInterval(function() {
      self.doGravity();
    }, Tetris.GRAVITY_DELAY);
  };


  Tetris.Controller.prototype.doGravity = function () {
    if (this.fallingPiece === null)
      return; // piece isn't initialized yet.

    var newPiece = this.fallingPiece.drop();

    // If we've hit the bottom, add the (pre-drop) piece to the board and create a new piece.
    if (this.myBoard.checkForPieceCollision(newPiece)) {
      this.myBoard.addLandedPiece(this.fallingPiece);

      // Check for completed lines and if appropriate, push extra rows to our opponent.
      var completedRows = this.myBoard.removeCompletedRows();
      var rowsToPush = (completedRows === 4) ? 4 : completedRows - 1;
      if (rowsToPush > 0)
        this.opponentPlayerRef.child('extrarows').push(rowsToPush);

      // Create new piece (it'll be initialized to a random piece at the top of the screen).
      newPiece = new Tetris.Piece();

      // Is the board full?
      if (this.myBoard.checkForPieceCollision(newPiece))
        this.gameOver();
    }

    newPiece.writeToFirebase(this.myPlayerRef.child('piece'));
  };


  /**
   * Detect when our opponent pushes extra rows to us.
   */
  Tetris.Controller.prototype.watchForExtraRows = function () {
    var self = this;
    var extraRowsRef = this.myPlayerRef.child('extrarows');
    extraRowsRef.on('child_added', function(snapshot) {
      var rows = snapshot.val();
      extraRowsRef.child(snapshot.key()).remove();

      var overflow = self.myBoard.addJunkRows(rows);
      if (overflow)
        self.gameOver();

      // Also move piece up to avoid collisions.
      if (self.fallingPiece) {
        self.fallingPiece.y -= rows;
        self.fallingPiece.writeToFirebase(self.myPlayerRef.child('piece'));
      }
    });
  };


  /**
   * Detect when our opponent restarts the game.
   */
  Tetris.Controller.prototype.watchForRestart = function () {
    var self = this;
    var restartRef = this.myPlayerRef.child('restart');
    restartRef.on('value', function(snap) {
      if (snap.val() === 1) {
        restartRef.set(0);
        self.resetMyBoardAndPiece();
      }
    });
  };


  Tetris.Controller.prototype.gameOver = function () {
    this.restartGame();
  };


  Tetris.Controller.prototype.restartGame = function () {
    this.opponentPlayerRef.child('restart').set(1);
    this.resetMyBoardAndPiece();
  };


  Tetris.Controller.prototype.resetMyBoardAndPiece = function () {
    this.myBoard.clear();
    var newPiece = new Tetris.Piece();
    newPiece.writeToFirebase(this.myPlayerRef.child('piece'));
  };


  start();

</script>
</body>
</html>
<!-- saved from url=(0029)http://pintronweb.algolab.eu/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>PinW | A Pintronic Pintronator</title>

  
  <link rel="icon" type="image/png" href="http://pintronweb.algolab.eu/img/dalec.ico">

<!-- <link href="/css/bootstrap.min.css"      rel="stylesheet" media="screen">  -->
<link href="./PinW _ A Pintronic Pintronator_files/font-awesome.min.css" rel="stylesheet" media="screen">
<link href="./PinW _ A Pintronic Pintronator_files/main.css" rel="stylesheet" media="screen">
<link href="./PinW _ A Pintronic Pintronator_files/lavish2.css" rel="stylesheet" media="screen">
<link href="./PinW _ A Pintronic Pintronator_files/sweet-alert.css" rel="stylesheet" media="screen">
<link href="./PinW _ A Pintronic Pintronator_files/jquery-ui.min.css" rel="stylesheet" media="screen">
<link href="./PinW _ A Pintronic Pintronator_files/bootstrapValidator.min.css" rel="stylesheet" media="screen">
<link href="./PinW _ A Pintronic Pintronator_files/jquery-timepicker.css" rel="stylesheet" media="screen">
<link href="./PinW _ A Pintronic Pintronator_files/bootstrap-table.css" rel="stylesheet" media="screen">
<link href="./PinW _ A Pintronic Pintronator_files/sticky-footer.css" rel="stylesheet" media="screen">


<style type="text/css">:root .container > .infoBoxList > .shareInfoBox
{display:none !important;}</style><style type="text/css"></style><script type="text/javascript" src="./PinW _ A Pintronic Pintronator_files/sweet-alert.min.js"></script>
<script type="text/javascript" src="./PinW _ A Pintronic Pintronator_files/jquery.min.js"></script>
<script type="text/javascript" src="./PinW _ A Pintronic Pintronator_files/bootstrap.min.js"></script>
<script type="text/javascript" src="./PinW _ A Pintronic Pintronator_files/jquery-ui.min.js"></script>
<script type="text/javascript" src="./PinW _ A Pintronic Pintronator_files/bootstrapValidator.min.js"></script>
<script type="text/javascript" src="./PinW _ A Pintronic Pintronator_files/jquery-timepicker.js"></script>
<script type="text/javascript" src="./PinW _ A Pintronic Pintronator_files/navbar.js"></script>
<script type="text/javascript" src="./PinW _ A Pintronic Pintronator_files/bootstrap-table.js"></script>

  <script type="text/javascript" src="./PinW _ A Pintronic Pintronator_files/index.js"></script>
<link rel="stylesheet" type="text/css" href="chrome-extension://pkehgijcmpdhfbdbbnkijodmdjhbjlgp/skin/socialwidgets.css"></head>
<body>




  

  <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <a class="navbar-brand" href="http://pintronweb.algolab.eu/">PinW</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        
        <li><a href="http://pintronweb.algolab.eu/results">Results</a></li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
        
          <li><a data-toggle="modal" data-target="#login">Login</a></li>
        
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>


<!-- Modal -->
<div class="modal fade" id="login" tabindex="-1" role="dialog" aria-labelledby="loginLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">Ã—</span><span class="sr-only">Close</span></button>
        <h4 class="modal-title" id="loginLabel">Enter nickname and password to login</h4>
      </div>
      <div class="modal-body">
        
        <form role="form" class="form-horizontal" method="post" action="http://pintronweb.algolab.eu/login">
          <div class="form-group">
            <label for="InputUser" class="col-md-4 control-label">Nickname</label>
            <div class="col-md-8">
              <input type="text" class="form-control" id="InputUser" placeholder="Enter nickname" name="InputUser" required="" autofocus="autofocus">
            </div>
          </div>

          <div class="form-group">
            <label for="InputPassword" class="col-md-4 control-label">Password</label>
            <div class="col-md-8">
              <input type="password" class="form-control" id="InputPassword" placeholder="Password" name="InputPassword" required="">
            </div>
          </div>

          

          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
            <button type="submit" class="btn btn-primary">Login</button>
          </div>
        </form>
      </div>
    </div>
  </div>
</div>


  <div id="mycarousel" class="carousel slide" data-ride="carousel">
    <div class="carousel-inner">
      <div class="item active">
        <img src="./PinW _ A Pintronic Pintronator_files/owpq53W.jpg" alt="" class="img-responsive">
        <div class="carousel-caption">
        <p class="enorme">Pintron, a pintronic pintronator!</p>
        <a href="http://pintronweb.algolab.eu/quick_new_job" class="btn btn-primary btn-lg">
          <i class="fa fa-cube"></i> Create a new job!
        </a>
        </div>
      </div>
    </div>
  </div>

<script src="anime.min.js"></script>
<script>
var myAnimation = anime({
  targets: ['.blue', '.green'],
  translateX: '13rem',
  rotate: 180,
  borderRadius: 8,
  duration: 2000,
  loop: true
});
</script>


<div><div class="sweet-overlay" tabindex="-1"></div><div class="sweet-alert" tabindex="-1"><div class="icon error"><span class="x-mark"><span class="line left"></span><span class="line right"></span></span></div><div class="icon warning"> <span class="body"></span> <span class="dot"></span> </div> <div class="icon info"></div> <div class="icon success"> <span class="line tip"></span> <span class="line long"></span> <div class="placeholder"></div> <div class="fix"></div> </div> <div class="icon custom"></div> <h2>Title</h2><p>Text</p><button class="cancel" tabindex="2">Cancel</button><button class="confirm" tabindex="1">OK</button></div></div></body></html>
<!-- Firebase -->
<script src="https://cdn.firebase.com/js/client/2.2.4/firebase.js"></script>
<!-- AngularFire -->
<script src="https://cdn.firebase.com/libs/angularfire/1.2.0/angularfire.min.js"></script>
	<head>
		<title>Interface of structure gene</title>
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta charset="UTF-8" >
		<link href="Css/d3-structure_gene.css" rel="stylesheet" type="text/css">
		<link href="bootstrap-3.2.0-dist/css/bootstrap.css" rel="stylesheet" type="text/css">
		<link href="bootstrap-3.2.0-dist/css/bootstrap-theme.css" rel="stylesheet" type="text/css">

		<title>Interface of structure gene</title>
		<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
		<script src="http://d3js.org/d3.v3.js"> charset="utf-8"</script>
		<script src="http://code.jquery.com/jquery-1.11.1.min.js"> charset="utf-8"</script>
		
		<script src="bootstrap-3.2.0-dist/js/bootstrap.min.js" charset="utf-8"></script>
		<script src = "Js/d3-transform/src/d3-transform.js" charset="utf-8"></script>
		
		<script type = "text/javascript" src = "Js/d3-structure_gene.js" charset="utf-8"></script>
		
	</head>

	<body>
		<!-- Navigation bar -->
		<nav class="navbar navbar-default" role="navigation">
  			<div class="container-fluid">
    			<div class="navbar-header">
      				<a id="home_gene" class="navbar-brand" href="#"></a>
    			</div>
    			<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      				<ul class="nav navbar-nav">
        				<li class="dropdown">
        					<a href="#" class="dropdown-toggle" data-toggle="dropdown">File structure information</a>
          					<ul id="info_gene" class="dropdown-menu" role="menu">
          					</ul>
        				</li>
        				<li class="dropdown">
          					<a href="#" class="dropdown-toggle" data-toggle="dropdown">Select Gene <span class="caret"></span></a>
          					<ul id="select_gene" class="dropdown-menu" role="menu"></ul>
        				</li>
      				</ul> 
      				<button id="zoom_button_on" type="button" class="btn btn-default">Zoom On</button> 
      				<button id="zoom_button_off" type="button" class="btn btn-default">Zoom Off</button> 
      				<button id="reset_button" type="button" class="btn btn-default">Reset</button> 
    			</div>
  			</div>
		</nav>
		
		<script type = "text/javascript">
			window.onload = setup_interface;
		</script>
		<!-- Modal window -->
		<div id="myModal" class="modal fade">
 			<div class="modal-dialog">
  				<div class="modal-content">
  					<div id="modal_t" class="modal-header">
    					<button type="button" class="close" data-dismiss="modal">&times;</button>
   					</div>
   					<div id="modal_body" class="modal-body">
   					</div>
   					<div class="modal-footer">
   						<button type="button" class="btn btn-success" data-toggle="tooltip" data-placement="bottom" title="Coming Soon!">Download</button>
   						<button type="button" class="btn btn-success" data-dismiss="modal">Chiudi</button>
   					</div>
  				</div>
 			</div>
</div> 
</body> 
<script src="https://d3js.org/d3-array.v1.min.js"></script>
<script src="https://d3js.org/d3-geo.v1.min.js"></script>
<script>

var path = d3.geoPath();

</script>
<script>
/* D3 Inteface of structure gene (https://bitbucket.org/Andre_T)
 * 
 * Copyright (C) 2014 Andrea Tornaghi
 * Licensed under GPLv3 (http://www.gnu.org/licenses/gpl.html)
 */


//margini
var margin_isoform = {top: 100, right: 15, bottom: 15, left: 10};

//dimensione della finestra di visualizzazione dell'isoforma
var height = window.innerHeight + 100 - margin_isoform.top - margin_isoform.bottom;
var width = window.innerWidth;
var width_isoform = 300;
var height_isoform = 250;

//dimensioni fisse della finestra degli elementi selezionati (struttura espansa)
var s_w = width - margin_isoform.left - margin_isoform.right;
var s_h = 300;

//flag per segnalare l'attivazione della struttura, dello zoom e 
//della presenza della sequenza nucleotidica
var flag_structure = false, flag_zoom = false, flag_sequence = false, flag_exon = true;

//stringa per il nome del gene da visualizzare
var string_gene = "ATP6AP1";
//stringa per il pathname del file json
var default_structure = "ATP6AP1example2.json";


//rimuove i duplicati da un array (indipendente dal tipo di elemento)
var remove_duplicate = function(a) {
	
	var new_a = [], a_l = a.length, found, x, y;
	
	for (x = 0; x < a_l; x++){
		found = undefined;
		for (y = 0; y < new_a.length; y++){
			if (a[x] === new_a[y]){
				found = true;
        		break;
            }
        }
        if (!found) {
            new_a.push(a[x]);
        }
    }
    return new_a;
 };
 
 //funzione per lo zoom della struttura genica
 var zoom_isoform = d3.behavior.zoom()
 	.scaleExtent([1.5, 3])
  	.on("zoom", zoom);
//funzione per traslare e scalare la struttura genica
//in base alle coordinate del mouse 
function zoom() {
 	svg_isoform.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
 }


/* EXONS_STRUCTURE
 * extract_exons -> dati degli esoni estratti dal file json
 * extract_regions -> dati delle regioni estratti dal file json
 * extract_boundary -> dati dei boundaries estratti dal file json
 * 
 * Crea la struttura dei dati per gli esoni. Concatena le sequenze
 * nucleotidiche delle regioni, riporta gli ID delle regioni
 * che compongono l'esone e la lunghezza in bp di ogni esone.
 */
function exons_structure (extract_exons, extract_regions, extract_boundary) {
		
	//array di oggetti "esone"
	var exons = [];
	//numero di esoni
	var l = extract_exons.length;
	
	for (i = 0; i < l; i++) {
		var reg = [];
		//proprietÃ  esone
		var exon_prop = {
			//left & right boundary
			l_b : extract_exons[i].left_boundary,
			r_b : extract_exons[i].right_boundary,
			annot : extract_exons[i].annotated,
			//sequenza nucleotidica
			seq : "",
			flag_seq : false,
			flag_alt : false,
		};
		
		var region_prop = {
			//regione boundary di sinistra
			r_l : extract_regions[extract_boundary[exon_prop.l_b].first + 1],
			//regione boundary di destra
			r_r : extract_regions[extract_boundary[exon_prop.r_b].first]
		};
		
		var boundary_prop = {	
			//tipologia regione di sinistra	
			t_r_l : region_prop.r_l.type,
			//tipologia regione di destra
			t_r_r : region_prop.r_r.type
		};
		
		//condizioni estratte da "propostaJSON2.txt"
		//esclude le regioni non codificanti
		if ((boundary_prop.t_r_l == "codifying") & (boundary_prop.t_r_l != "unknow")) {
			start_exon = region_prop.r_l.start;
			if ((boundary_prop.t_r_r == "codifying") & (boundary_prop.t_r_r != "unknow"))
				end_exon = region_prop.r_r.end;
			
			//assembla la sequenza nucleotidica e salva le regioni appartenenti all'esone
			for (j = region_prop.r_l.id; j <= region_prop.r_r.id; j++) {
				if (extract_regions[j].sequence == null)
					exon_prop_flag.seq = true;
				else {
					if(extract_regions[j].type == "codifying")
						exon_prop.seq = exon_prop.seq.concat(extract_regions[j].sequence);
					else 
						exon_prop.flag_seq = true;
					}
				reg.push(extract_regions[j].id);
				
				if(extract_regions[j].alternative == true)
					exon_prop.flag_alt = true;
				
			}
			
			if (exon_prop.flag_seq == true)
				exon_prop.seq = null;
				
			//assembla l'oggetto esone
			exons.push({
					"id" : i,
					"start" : start_exon,
					"end" : end_exon,
					"sequence" : exon_prop.seq,
					"regions" : reg,
					"alternative" : exon_prop.flag_alt,
					"annotated" : exon_prop.annot,
					"length" : (end_exon - start_exon + 1) + " bp"
			});
			reg = [];
		}
	}
	return exons;	
}


/* INTRONS_STRUCTURE
 * extract_introns -> dati degli introni estratti dal file json
 * extract_regions -> dati delle regioni estratti dal file json
 * extract_boundary -> dati dei boundaries estratti dal file json
 * 
 * Crea la struttura dei dati per gli introni. Concatena le sequenze
 * nucleotidiche delle regioni, riporta gli ID delle regioni
 * che compongono l'introne, calcola il pattern dai suffissi e prefissi
 * delle regioni che compongono l'introne e calcola la lunghezza
 * dellintrone in bp.
 */
function introns_structure(extract_introns, extract_regions, extract_boundary){
	
	//numero di introni
	var l = extract_introns.length;
	//array di oggetti "introne"
	var introns = [];
	
	for(i = 0; i < l; i++){
		var reg = [];
		var intron_prop = {
			//stringa per la sequenza nucleotidica
			seq : "",
			flag_seq : false,
			flag_intron_ok : true,
			//left & right boundary
			l_b : extract_introns[i].left_boundary,
			r_b : extract_introns[i].right_boundary,
			pattern : ""
		};
		
		var region_prop = {
			//regione boundary di sinistra
			r_l : extract_regions[extract_boundary[intron_prop.l_b].first + 1],
			//regione boundary di destra
			r_r : extract_regions[extract_boundary[intron_prop.r_b].first]
		};
		
		var boundary_prop = {
			//tipologia regione di sinistra	
			t_r_l : region_prop.r_l.type,
			//alternative
			a_r_l : region_prop.r_l.alternative,
			//tipologia regione di destra
			t_r_r : region_prop.r_r.type,
			//alternative
			a_r_r : region_prop.r_r.alternative
		};
		
		//condizioni estratte da "propostaJSON2.txt"
		//esclude le regioni non codificanti
		if((boundary_prop.t_r_l != "unknow") & (boundary_prop.t_r_r != "unknow")){
			if((extract_boundary[intron_prop.l_b].type ==  "5") | (extract_boundary[intron_prop.l_b].type == "both")){
				if((boundary_prop.t_r_l == "codifying") & (boundary_prop.a_r_l == true))
					start_intron = region_prop.r_l.start;
				else
					if(boundary_prop.t_r_l == "spliced")
						start_intron = region_prop.r_l.start;
					else
						intron_prop.flag_intron_ok == false;
			}
			else
				intron_prop.flag_intron_ok = false;	
			if((extract_boundary[intron_prop.r_b].type ==  "3") | (extract_boundary[intron_prop.r_b].type == "both")){
				if((boundary_prop.t_r_r == "codifying") & (boundary_prop.a_r_r == true))
					end_intron = region_prop.r_r.end;
				else
					if(boundary_prop.t_r_r == "spliced")
						end_intron = region_prop.r_r.end;
					else
						intron_prop.flag_intron_ok = false;
			}
			else
				intron_prop.flag_intron_ok = false;
		}
		else
			intron_prop.flag_intron_ok = false;
				
		if(intron_prop.flag_intron_ok){
			//assembla la sequenza nucleotidica e salva le regioni appartenenti all'introne
			for(j = region_prop.r_l.id; j <= region_prop.r_r.id; j++){
			
				if(extract_regions[j].sequence == null)
					intron_prop.flag_seq = true;
				else{
					if(((extract_regions[j].type == "codifying") & (extract_regions[j].alternative == true)) | extract_regions[j].type == "spliced")
						intron_prop.seq = intron_prop.seq.concat(extract_regions[j].sequence);
					else
						intron_prop.flag_seq = true;
					}
			
				reg.push(extract_regions[j].id);
			}
			
		    if(intron_prop.flag_seq == true)
				intron_prop.seq = null;
		
		    //suffisso e prefisso della sequenza nucleotidica
			var l_suffix = extract_introns[i].suffix.length;
			intron_prop.pattern = extract_introns[i].prefix.substr(0, 2).concat(extract_introns[i].suffix.substr(l_suffix - 2, l_suffix));
			
			//assembla l'oggetto introne
			introns.push({
					"start" : start_intron,
					"end" : end_intron,
					"sequence" : intron_prop.seq,
					"suffix" : extract_introns[i].suffix,
					"prefix" : extract_introns[i].prefix,
					"pattern" : intron_prop.pattern,
					"regions" : reg,
					"id" : i,
					"length" : (end_intron - start_intron + 1) + " bp"
			});
			reg = [];		
		}	
	}	
	return introns;	
}


/* SPLICE_SITES_STRUCTURE
 * extract_boundaries -> dati dei boundary estratti dal file json
 * extract_regions -> dati delle regioni estratti dal file json
 * 
 * Crea la struttura dei dati per gli splice_sites. Riporta la posizione
 * e la tipologia di ogni splice_sites 
 */
function splice_site_structure(extract_boundaries, extract_regions){
	
	//numero dei boundaries
	var l = extract_boundaries.length;
	//array di oggetti "splice sites"
	var s_s = [];
	
	var boundary_prop = {
		//posizione
		pos : null,
		//tipologia
		t : ""
	};
	
	//condizioni estratte da "propostaJSON2.txt"
	for(i = 0; i < l; i++){
		if(extract_boundaries[i].first == -1){
			boundary_prop.pos = null;
			boundary_prop.t = "unknow";
		}	
		else{
			boundary_prop.t = extract_boundaries[i].type;	
			if((boundary_prop.t == "5") | (boundary_prop.t == "both"))
				boundary_prop.pos = extract_regions[extract_boundaries[i].first + 1].start;
			if((boundary_prop.t == "3") | (boundary_prop.t == "term"))
				boundary_prop.pos = extract_regions[extract_boundaries[i].first].end;
			if(boundary_prop.t == "init")
				boundary_prop.pos = extract_regions[extract_boundaries[i].first].start;
						
			//assembla l'oggetto splice sites
			s_s.push({
				"position" : boundary_prop.pos,
				"type" : boundary_prop.t,
				"id" : i			
			});
		}
	}	
	return s_s;
}


/* ISOFORM_RANGE
 * reg -> dati delle regioni estratti dal file json
 * 
 * Definisce un range per trasformare la posizione (start & end) 
 * dei blocchi nell'isoforma in coordinate della finestra 
 * di visualizzazione.
 */
function isoform_range(reg) {
	
	//range per la finestra della struttura
	var x = d3.scale.log()
		.rangeRound([0, width - width_isoform - margin_isoform.left - margin_isoform.right], .1);				
	//valorei minimo e massimo di inizio e fine dei blocchi
	var min = d3.min(reg, function(d) { return d.start; });
	var max = d3.max(reg, function(d) { return d.end; });
	
	x.domain([min, max], .1);
	
	return x;
}


/* SET_SVG
 * c -> classe
 * w -> width
 * h -> height
 * p -> array per la posizione
 * 
 * Crea un elemento "svg", specificando la posizione, 
 * la dimensione e la classe
 */
function set_svg(c, w, h, p){
	
	var svg = d3.select("body").append("svg")
		.attr("id", c)
		.attr("width", w)
		.attr("height", h)
		.style("position", p.pos)
		.style("left", p.left)
		.style("right", p.right)
		.style("top", p.top);	
	
	return svg;
}


/* EXPANDE_BOX_RANGE (DEPRECATED)
 * reg -> regioni dell'esone selezionato
 * h_info -> altezza finestra 
 * 
 * Ritorna una funzione che riscala ogni valore nel range 
 * della finestra di visualizzazione.
 * Non viene utilizzata nelle versione piÃ¹ recente perchÃ¨
 * la finestra della struttura espansa ha la stessa dimensione
 * della finestra dell'isoforma
 */
function expande_box_range(reg, w_info){
	
	//range per la finestra degli elementi selezionati
    y = d3.scale.log()
    	.rangeRound([0, w_info], .1);
                
    //valorei minimo e massimo di inizio e fine dei blocchi
    var min_r = d3.min(reg[0], function(d) { return d.start; });
    var max_r = d3.max(reg[0], function(d) { return d.end; });
    
    if(reg.length > 1){
    	min_i = d3.min(reg[1], function(d) { return d.start; });
        max_i = d3.max(reg[1], function(d) { return d.end; });
    }
    else{
        min_i = min_r;
        max_i = max_r;
    }
    
    if(min_r <= min_i)
        min = min_r;
    else
        min = min_i; 
    
    if(max_r >= max_i)
        max = max_r;
    else
        max = max_i;
    
    y.domain([min, max], .1);
    
    return y;
}


/* LEGEND_BOX
 * 
 * Visualizza la legenda per gli elementi delle struttura
 * del gene
 */
function legend_box(){
	
	//bordo della finestra SVG
	border_width = 8;
	
    //dimensioni fisse degli elementi della legenda
    l_w = width_isoform - margin_isoform.right - margin_isoform.left - border_width;
    var l_h = 250;
    var off_set = 80;
    var off_set_y = 25;
    var height_exon = 18;
    
    //durata e ritardo animazione
    var t = 750, d = 1500;
    
    //struttura per il posizionamento            
    var p_s = {
    	pos : "absolute", 
    	left : (width - width_isoform + margin_isoform.left + border_width) +  "px",
    	right : margin_isoform.right + "px",
    	top: "60px", 
    	bottom : "10px"
    };
       
    //variabile per traslare gli elementi
	var tf_element = d3.svg.transform()
		.translate(function () { return [20, 26]; });
	var tf_text = d3.svg.transform()
		.translate(function () { return [20, 30]; });
	
	var color_exon = function() { return d3.rgb("#228B22"); };
	var color_exon_stripe = function() { return 'url(#diagonalHatch)'; };
    var color_intron = function() { return d3.rgb("black"); };
    var color_splice_site = function() { return d3.rgb("black"); };
                                        
    //dichiarazione della finestra SVG
    var s_l = set_svg("legend", l_w, l_h, p_s);
   
    //"viewbox" rimappa le coordinate della finestra all'interno dei 
    //valori specificati dal risultato della funzione
    s_l.attr("viewbox", function() { return "0 0" + l_w + l_h; });

    //tipologia regioni
    s_l.append("rect")
    	.attr("x", 0)
    	.attr("y", 0)
    	.attr("width", 40)
    	.attr("height", height_exon)
    	.attr("transform", tf_element)
    	.style("fill", color_exon)
    	.style("opacity", "0.0")
    	.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");
    s_l.append("text")
    	.attr("x", off_set)
    	.attr("y", height_exon/2)
    	.style("font-size", "13px")
    	.style("font-family", "Arial, Helvetica, sans-serif")
    	.style("fill", "black")
    	.style("opacity", "0.0")
    	.attr("transform", tf_text)
    	.text("Alternative region")
    	.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");
    
    s_l.append("rect")
    	.attr("x", 0)
    	.attr("y", off_set_y)
    	.attr("width", 40)
    	.attr("height", height_exon)
    	.attr("transform", tf_element)
    	.style("fill", color_exon)
    	.style("opacity", "0.0")
    	.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");
    s_l.append("rect")
    	.attr("x", 0)
    	.attr("y", off_set_y)
    	.attr("width", 40)
    	.attr("height", height_exon)
    	.attr("transform", tf_element)
    	.style("fill", color_exon_stripe)
    	.style("opacity", "0.0")
    	.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");
    s_l.append("text")
    	.attr("x", off_set)
    	.attr("y", height_exon/2 + off_set_y)
    	.style("font-size", "13px")
    	.style("font-family", "Arial, Helvetica, sans-serif")
    	.style("fill", "black")
.style("opacity", "0.0")
	.attr("transform", tf_text)
    	.text("Conserved region")
    	.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");
    
    //tipologia introni	
    s_l.append("line")
    	.attr("x1", 0)
    	.attr("y1", off_set_y*2 + 20)
		.attr("x2", 40)
		.attr("y2", off_set_y*2 + 20)
    	.attr("transform", tf_element)
    	.style("stroke", color_intron)
    	.style("stroke-width", 6)
    	.style("opacity", "0.0")
    	.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");
    s_l.append("text")
    	.attr("x", off_set)
    	.attr("y", off_set_y*2 + 20)
    	.style("font-size", "13px")
    	.style("font-family", "Arial, Helvetica, sans-serif")
    	.style("fill", "black")
    	.style("opacity", "0.0")
    	.attr("transform", tf_text)
    	.text("Intron")
    	.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");
    
    //tipologia splice sites 
    var s_sy = d3.svg.symbol()
		.type('triangle-up')
		.size(10);
	//tipo 3'
    s_l.append("line")
    	.attr("x1", 0)
    	.attr("y1", off_set_y * 3.8)
		.attr("x2", 0)
		.attr("y2", off_set_y * 3.8 + 20)
    	.attr("transform", tf_element)
    	.style("stroke", color_intron)
    	.style("stroke-width", 2)
    	.style("opacity", "0.0")
    	.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");	
	
	var position_t = 22;									
	s_l.append("path")
		.attr("d", s_sy)
		.attr("fill", "none")
		.attr("stroke","black")
		.attr("stroke-width", "1px")
		.style("opacity", "0.0")
		.attr("transform", function () {
							 return "translate(" + position_t + "," + (off_set_y * 3.8 + 24) + ")" + "rotate(90)";  })
		.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");
	s_l.append("path")
		.attr("d", s_sy)
		.attr("fill", "none")
		.attr("stroke","black")
		.attr("stroke-width", "1px")
		.style("opacity", "0.0")
		.attr("transform", function () {
							 return "translate(" + position_t + "," + (off_set_y * 3.8 + 47) + ")" + "rotate(90)";  })
		.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");
	    
	s_l.append("text")
    	.attr("x", off_set)
    	.attr("y", off_set_y * 3.8 + 10)
    	.style("font-size", "13px")
    	.style("font-family", "Arial, Helvetica, sans-serif")
    	.style("fill", "black")
    	.style("opacity", "0.0")
    	.attr("transform", tf_text)
    	.text("5' Splice site").transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0"); 
	    
	//tipo 5'
    s_l.append("line")
    	.attr("x1", 0)
    	.attr("y1", off_set_y * 5)
		.attr("x2", 0)
		.attr("y2", off_set_y * 5 + 20)
    	.attr("transform", tf_element)
    	.style("stroke", color_intron)
    	.style("stroke-width", 2)
    	.style("opacity", "0.0")
    	.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");	
	
	position_t = 18;									
	s_l.append("path")
		.attr("d", s_sy)
		.attr("fill", "none")
		.attr("stroke","black")
		.attr("stroke-width", "1px")
		.style("opacity", "0.0")
		.attr("transform", function () {
							 return "translate(" + position_t + "," + (off_set_y * 5 + 24) + ")" + "rotate(-90)";  })
		.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");
	s_l.append("path")
		.attr("d", s_sy)
		.attr("fill", "none")
		.attr("stroke","black")
		.attr("stroke-width", "1px")
		.style("opacity", "0.0")
		.attr("transform", function () {
							 return "translate(" + position_t + "," + (off_set_y * 5 + 47) + ")" + "rotate(-90)";  })
		.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");
	s_l.append("text")
    	.attr("x", off_set)
    	.attr("y", off_set_y * 5 + 10)
    	.style("font-size", "13px")
    	.style("font-family", "Arial, Helvetica, sans-serif")
    	.style("fill", "black")
    	.style("opacity", "0.0")
    	.attr("transform", tf_text)
    	.text("3' Splice site").transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");
	    
	 //tipologia esoni
    s_l.append("rect")
    	.attr("x", 0)
    	.attr("y", off_set_y * 6.5)
    	.attr("width", 40)
    	.attr("height", height_exon)
    	.attr("transform", tf_element)
    	.style("fill", function() { return d3.rgb("#ADD8E6"); })
    	.style("opacity", "0.0")
    	.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");
    s_l.append("text")
    	.attr("x", off_set)
    	.attr("y", off_set_y * 6.5 + height_exon/2)
    	.style("font-size", "13px")
    	.style("font-family", "Arial, Helvetica, sans-serif")
    	.style("fill", "black")
    	.style("opacity", "0.0")
    	.attr("transform", tf_text)
    	.text("Novel exon")
    	.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");
    
    s_l.append("rect")
    	.attr("x", 0)
    	.attr("y", off_set_y * 7.5)
    	.attr("width", 40)
    	.attr("height", height_exon)
    	.attr("transform", tf_element)
    	.style("fill", function() { return d3.rgb("#ADD8E6"); })
    	.style("stroke", function() { return d3.rgb("#00008B"); })
    	.style("stroke-width", "3px")
    	.style("opacity", "0.0")
    	.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");
    s_l.append("text")
    	.attr("x", off_set)
    	.attr("y", height_exon/2 + off_set_y * 7.5)
    	.style("font-size", "13px")
    	.style("font-family", "Arial, Helvetica, sans-serif")
    	.style("fill", "black")
    	.style("opacity", "0.0")
    	.attr("transform", tf_text)
    	.text("Annotated exon")
    	.transition()
	    .delay(d)
	    .duration(t)
	    .style("opacity", "1.0");
}


/* REMOVE_ELEMENT_EXPANDE_BOX
 * 
 * Funzione eseguita alla pressione del tasto "Reset", alla
 * selezione di un nuovo gene e al click sul nome del gene
 * nella navigation bar. Elimina tutti gli elementi nella
 * finestra della struttura espansa. Ripristina le dimensioni
 * originali della struttura e tutte le sue funzioni, disabilita
 * lo zoom.
 */
function remove_element_expande_box(){
	
	//durata animazione
	var t = 750;
	
	d3.select("#zoom_button_on")
    	.attr("class", "btn btn-default");
	
	//rimozione segnalatore click del mouse
	d3.selectAll("#cross_pos").remove();
	
	//ripristino esoni "conservated"
	d3.selectAll("#exon")
    	.transition()
        .duration(750)
        .style("opacity","1.0")
    	.attr("pointer-events", "yes")
      	.style("stroke-width", 0)
      	.style("fill", function() { return d3.rgb("#228B22"); });
    
    //ripristino esoni "alternative"                               
    d3.selectAll("#exon_stripe")
    	.transition()
        .duration(t)
        .style("opacity","1.0")
    	.attr("pointer-events", "yes")
        .style("stroke-width", 0)
        .style("fill", 'url(#diagonalHatch)');
    d3.select("#exon_stripe_over")
    	.transition()
        .duration(t)
        .style("opacity", "0.0")
    	.remove();                    
    d3.selectAll("#exon_stripes")
    	.transition()
        .duration(t)
        .style("opacity","1.0")
    	.attr("pointer-events", "yes")
        .style("stroke-width", 0)
        .style("fill", function() { return d3.rgb("#228B22"); });
    
    //ripristino introni                    
    d3.selectAll("#intron")
    	.transition()
        .duration(t)
        .style("opacity","1.0")
    	.style("stroke", "black")
    	.attr("pointer-events", "yes");
    
    //ripristino splice sites
    var s;
    for(s = 0; s < s_s_restruct.length; s++){
    	d3.select("#s_s_" + s_s_restruct[s].id)
    		.transition()
        	.duration(t)
        	.style("opacity","1.0")
    		.style("stroke", "black")
    		.style("stroke-width", "1px");
    	d3.select("#up_" + (s_s_restruct[s].id - 1))
            .transition()
        	.duration(t)
        	.style("opacity","1.0")
    		.style("stroke", "black");
        d3.select("#down_" + (s_s_restruct[s].id - 1))
            .transition()
        	.duration(t)
        	.style("opacity","1.0")
    		.style("stroke", "black");
    }
	
	//rimizione struttura espansa
	d3.select("#regions_selected")
		.transition()
    	.duration(t)
    	.style("opacity", "0.0")
		.remove(); 
	
	//rimozione elementi aggiunti
	d3.selectAll("#exon_s")
		.transition()
    	.duration(t)
    	.style("opacity", "0.0")
		.remove();	
	d3.selectAll("#intron_s")
		.transition()
    	.duration(t)
    	.style("opacity", "0.0")
		.remove();
    
    //rimozione sequenza nucleotidica                    		    
    d3.select("#title_sequence")
    	.transition()
    	.duration(t)
    	.style("opacity", "0.0")
    	.remove();    
    d3.select("#sequence_ex")
    	.transition()
    	.duration(t)
    	.style("opacity", "0.0")
    	.remove();
    d3.select("#sequence_in")
    	.transition()
    	.duration(t)
    	.style("opacity", "0.0")
    	.remove();
    d3.select("#table_title")
    	.transition()
    	.duration(t)
    	.style("opacity", "0.0")
    	.remove();
    d3.select("#table_start")
    	.transition()
    	.duration(t)
    	.style("opacity", "0.0")
    	.remove();
    d3.select("#table_end")
    	.transition()
    	.duration(t)
    	.style("opacity", "0.0")
    	.remove(); 
    
    flag_structure = false;
    flag_sequence = false;
}


/* BUTTONS
 * 
 * Configura i pulsanti per il reset e lo zoom della struttura.
 */
function buttons(){
	
	//durata animazione
	var d = 450;
	
	//pulsante per cancellare il contenuto della finestra della struttura
	// espansa e riattivare la struttura del gene
	d3.select("#reset_button") 
    	.style("position", "relative")
    	.style("top", "10px")   	
        .on("click", function() {
        				remove_element_expande_box();
        				//riporta la struttura genica alle dimensioni originali
        				zoom_isoform.translate([0, 0]).scale(1);
        				svg_isoform.transition()
        					.duration(d)
        					.attr("transform", "translate(" + zoom_isoform.translate() + ")scale(" + zoom_isoform.scale() + ")");
        				}
        	);
    //pulsante per attivare la funzione di zoom
    d3.select("#zoom_button_on")
   		.style("position", "relative")
    	.style("top", "10px")
        .on("click", function() {
        				//non compatibile con tutti i browser!
        				svg_isoform.style("cursor", "zoom-in");
        				
        				//disabilita gli eventi mouse sulla struttura genica
        				d3.selectAll("#exon")
        					.attr("pointer-events", "none");
      					d3.selectAll("#exon_stripe")
      						.attr("pointer-events", "none");
	   					d3.select("#exon_stripe_over")
    						.attr("pointer-events", "none");                       
    					d3.selectAll("#exon_stripes")
    						.attr("pointer-events", "none");                        
    					d3.selectAll("#intron")
    						.attr("pointer-events", "none");    
        				
        				//la sequenza nucleotidica viene resa invisibile
        				//per evitare l'effetto dell'ingrandimento
        				d3.select("#title_sequence")
        					.transition()
        					.duration(d)
        					.style("opacity", "0.0");
        				d3.select("#sequence_ex")
        					.transition()
        					.duration(d)
        					.style("opacity", "0.0");
        				d3.select("#sequence_in")
        					.transition()
        					.duration(d)
        					.style("opacity", "0.0");
        				
        				d3.select("#zoom_button_on")
        					.attr("class", "btn btn-primary");
        					
        				flag_zoom = true;
        				zoom_isoform(svg_isoform); 
        				}
        	);
    
    //pulsante per disattivare lo zoom e ripristinare la struttura
    d3.select("#zoom_button_off")
   		.style("position", "relative")
    	.style("top", "10px")
        .on("click", function(){
        				//riporta la struttura genica alle dimensioni originali
        				zoom_isoform.translate([0, 0]).scale(1);
        				svg_isoform.transition()
        					.duration(d)
        					.attr("transform", "translate(" + zoom_isoform.translate() + ")scale(" + zoom_isoform.scale() + ")");
        			
        				//attiva gli eventi mouse sulla struttura genica		
        				d3.selectAll("#exon")
        					.attr("pointer-events", "yes");
      					d3.selectAll("#exon_stripe")
      						.attr("pointer-events", "yes");
	   					d3.select("#exon_stripe_over")
    						.attr("pointer-events", "yes");                       
    					d3.selectAll("#exon_stripes")
    						.attr("pointer-events", "yes");                        
    					d3.selectAll("#intron")
    						.attr("pointer-events", "yes");
    					
    					//rende visibile la sequenza nucleotidica	
        				d3.select("#title_sequence")
        					.transition()
        					.duration(d)
        					.style("opacity", "1.0");
        				d3.select("#sequence_ex")
        					.transition()
        					.duration(d)
        					.style("opacity", "1.0");
        				d3.select("#sequence_in")
        					.transition()
        					.duration(d)
        					.style("opacity", "1.0");
        				
        				d3.select("#zoom_button_on")
        					.attr("class", "btn btn-default");
        				
        				svg_isoform.style("cursor", "default");
        				
        				flag_zoom = false;
        				//disattiva gli eventi corrispondenti allo zoom
        				//nella finestra della struttura genica
        				svg_isoform.on("mousedown.zoom", null);
						svg_isoform.on("mousemove.zoom", null);
						svg_isoform.on("dblclick.zoom", null);
						svg_isoform.on("touchstart.zoom", null);
						svg_isoform.on("wheel.zoom", null);
						svg_isoform.on("mousewheel.zoom", null);
						svg_isoform.on("MozMousePixelScroll.zoom", null);
        		});   
}

/* SVG_EXPANDE_BOX
 * 
 * Crea una finestra dove saranno visualizzati gli elementi
 * appartenenti alla selezione e le rispettive informazioni
 * su "start" e "end". 
 */
function svg_expande_box(){
	    
    //oggetto per il posizionamento            
    var p_s = {
    	pos : "absolute", 
    	left : "10px",
    	right : "10px",
    	top: "320px", 
    	bottom : "10px"
    };
    
    //dichiara finestra SVG                               
    var s_i = set_svg("expande_box", s_w, s_h, p_s);
    s_i.attr("viewbox", function() { return "0 0" + s_w + s_h; })
    	.style("overflow-y", "auto");
    
    return s_i;
}


/* REGIONS_SELECT
 * c_x -> coordinate (piano X) della posizione del mouse
 *
 * Seleziona la regione che contiene le coordinate rimappate del mouse. 
 * Rimuove tutti gli elementi di una eventuale selezione precedente 
 */
function regions_select(c_x){
	
	//ad ogni click vengono visualizzati gli elementi selezionati
	//senza resettare la struttura genica
	d3.select("#regions_selected")
		.transition()
    	.duration(750)
    	.style("opacity", "0.0")
		.remove();
	
	//rimozione sequenza nucleotidica
	d3.select("#title_sequence_box")
    	.transition()
    	.duration(750)
    	.style("opacity", "0.0")
    	.remove();    
    d3.select("#sequence_ex")
    	.transition()
    	.duration(750)
    	.style("opacity", "0.0")
    	.remove();
    d3.select("#sequence_in")
    	.transition()
    	.duration(750)
    	.style("opacity", "0.0")
    	.remove();
    d3.select("#table_title")
    	.transition()
    	.duration(750)
    	.style("opacity", "0.0")
    	.remove();
    d3.select("#table_start")
    	.transition()
    	.duration(750)
    	.style("opacity", "0.0")
    	.remove();
    d3.select("#table_end")
    	.transition()
    	.duration(750)
    	.style("opacity", "0.0")
    	.remove(); 
    	
	var reg_ext;
	for(g = 0; g < regions.length; g++)
		if((c_x > (regions[g].start)) & (c_x < (regions[g].end)))
			reg_ext = regions[g];
			        	
	return reg_ext;
}



/* ELEMENT_SELECTED_EXON
 * e_i -> elemento "esone" selezionato
 * s -> posizione di "start" dell'elemento
 * e -> posizione di "end" dell'elemento
 * 
 * Disegna un nuovo esone nella stessa posizione di quello 
 * selezionato. Si ottiene cosÃ¬ l'effetto di evidenziare 
 * solo l'esone selezionato nella struttura espansa.
 */
function element_selected_exon(e_i, s, e){
    
    //traslazione elemento
    var tf_e = d3.svg.transform()
		.translate(function () { return [s, 0]; });
    
    var ex = e_i.append("rect")
        .attr("id", "element_info_exon")
        .attr("x", s)
        .attr("y", 0)
        .attr("width", function() { return e - s; })
        .attr("height", 75)
        .style("fill", function() { return d3.rgb("#228B22").brighter(3); });
    return ex;
}


/* CONNECT_EXON
* exon -> esone sulla struttura del gene
* sequence -> sequenza del'esone
*
* Crea un link tra l'esone selezionato e la corrispondente sequenza nucleotidica
*/
function connect_exon(exon, sequence){
	
	//coordinate degli elementi da collegare	
	var xr_s = +exon.attr("x");
	var yr_s = +exon.attr("y") + +exon.attr("height") + 1;
	var xt_s = +sequence.attr("x") + 4;
	var yt_s = +sequence.attr("y") - 4;
	
	var xr_e = +exon.attr("x") + +exon.attr("width");
	var yr_e = +exon.attr("y") + +exon.attr("height") + 1;
	var xt_e = +sequence.attr("x") + sequence.text().length*5.5 + 2;
	var yt_e = +sequence.attr("y") - 4;

	//oggetto che contiente le coordinate rimappate in "source" e "target"
    point = [{ "source" : { "x" : xr_s + margin_isoform.left, "y" : yr_s}, 
    		   "target" : { "x" : xt_s + (margin_isoform.left * 20), "y" : yt_s + 135}},
    		 { "source" : { "x" : xr_e + margin_isoform.left, "y" : yr_e}, 
    		   "target" : { "x" : xt_e + (margin_isoform.left * 20), "y" : yt_e + 135}} ];
    
    //variabile contenente la funzione D3 che crea i link tra due elementi	  
    var diagonal = d3.svg.diagonal()
    	.source(function(d) { return {"x":d.source.y, "y":d.source.x}; })            
    	.target(function(d) { return {"x":d.target.y, "y":d.target.x}; })
        .projection(function(d) { return [+d.y, +d.x + 50]; });
    
    //i link vengono aggiunti solo se lo zoom Ã¨ disattivato
    if(flag_zoom == false)
    	svg_isoform.selectAll(".link")
    		.data(point)
    		.enter().append("path")
    		.attr("class", "link")
    		.attr("id", "link_ex")
        	.attr("d", diagonal);      
}


/* CONNECT_INTRON
* intron -> introne sulla struttura del gene
* sequence -> sequenza del'esone
*
* Crea un link tra l'introne selezionato e la corrispondente sequenza nucleotidica
*/
function connect_intron(intron, sequence){
	
	//coordinate degli elementi da collegare
	var xr_s = +intron.attr("x1");
	var yr_s = +intron.attr("y1");
	var xt_s = +sequence.attr("x") + 4;
	var yt_s = +sequence.attr("y") - 4;
	
	var xr_e = +intron.attr("x2");
	var yr_e = +intron.attr("y2");
	var xt_e = +sequence.attr("x") + sequence.text().length*7;
	var yt_e = +sequence.attr("y") - 4;
	
	var off_set_s = off_set_ex + (margin_isoform.left * 20) - sequence.text().length*12 + 2;
	var off_set_e = off_set_ex + (margin_isoform.left * 20) - sequence.text().length*13;

    //oggetto che contiente le coordinate rimappate in "source" e "target"
    point = [{ "source" : { "x" : xr_s + margin_isoform.left, "y" : yr_s}, 
    		   "target" : { "x" : xt_s + (margin_isoform.left * 20) + off_set_s, "y" : yt_s + 135}},
    		 { "source" : { "x" : xr_e + margin_isoform.left, "y" : yr_e}, 
    		   "target" : { "x" : xt_e + (margin_isoform.left * 20) + off_set_e, "y" : yt_e + 135}} ];
    
    //variabile contenente la funzione D3 che crea i collegamenti tra due elementi		  
    var diagonal = d3.svg.diagonal()
    	.source(function(d) { return {"x":d.source.y, "y":d.source.x}; })            
    	.target(function(d) { return {"x":d.target.y, "y":d.target.x}; })
        .projection(function(d) { return [+d.y, +d.x + 50]; });
    
    //i link vengono aggiunti solo se lo zoom Ã¨ disattivato
    if(flag_zoom == false)    	
    	svg_isoform.selectAll(".link")
    		.data(point)
    		.enter().append("path")
    		.attr("id", "link_in")
    		.attr("class", "link")
        	.attr("d", diagonal);      
}


/* ELEMENT_SELECTED_INTRON
 * s -> posizione di "start" dell'elemento
 * e -> posizione di "end" dell'elemento
 * 
 * Disegna un nuovo introne nella stessa posizione di quello 
 * selezionato. Si ottiene cosÃ¬ l'effetto di evidenziare 
 * solo l'introne selezionato sulla struttura espansa.
 */
function element_selected_intron(s, e){
     
    var intron_selected = d3.select("#introns").append("line")
        .attr("id", "element_info_intron")
		.attr("x1", s)
		.attr("y1", 35)
		.attr("x2", e)
		.attr("y2", 35)
		.style("stroke", function() { return d3.rgb("black").brighter(3); })
		.style("stroke-width", 8);
		
	return intron_selected;
}


/* DISPLAY_INFO
 * s_i -> finestra creata per visualizzare le informazioni
 * x_iso -> dominio della finestra di visualizzazione degli elementi
 * 			(lo stesso della struttura genica)
 * elements -> elementi estratti dalla struttura del gene
 *             in base alla selezione.
 * r -> contenitore degli esoni
 * 
 * Visualizza gli elementi, appartenenti alla selezione sulla struttura genica, 
 * nella finestra della struttura espansa.
 */ 
function display_info(s_i, x_iso, elements, r){
    
    //elementi estratti dalla selezione
    var exons_info = elements.r_i;
    var introns_info = elements.i_i;
    
    //posizione e dimensione della tabella
    var start_table = s_w - width_isoform + margin_isoform.left + margin_isoform.right;
    var column_start = 50, column_end = 200;
    
    //valori originali delle regioni
    var o_s = {
		exons : original_structure(original_regions, 'exon'),
		introns: original_structure(original_regions, 'intron')
	};
	
	
    //colori degli elementi
    var color_exon = function() { return d3.rgb("#ADD8E6"); };
    var color_intron = function() { return d3.rgb("black"); };
          
    //variabili per le operazioni di trasformazione 
    var transf = {	
    	//traslazione esoni   
   		t_e : d3.svg.transform()
        	.translate(function (d, i) { return [x_iso(d.start), i * 45]; }),
        //traslazione introni
    	t_i : d3.svg.transform()
        	.translate(function (d, i) { return [0, (i * 20) + (exons_info.length * 45)]; }),
        //traslazione contenitore elementi 
    	tf_g : d3.svg.transform()
        	.translate(function () { return [10, 20]; }),
        tf_table_title : d3.svg.transform()
        	.translate(function () { return [start_table, 0]; }),
        tf_table_start : d3.svg.transform()
        	.translate(function () { return [start_table, 35]; }),
        tf_table_end : d3.svg.transform()
        	.translate(function () { return [start_table, 35]; })
       };
      
    var table_text = [];
    //crea il vettore contenente le informazioni degli esoni
    for(k = 0; k < exons_info.length; k++)
    	table_text.push(exons_info[k]);  	
    //crea il vettore contenente le informazioni degli introni
    if(introns_info != null)
    	for(k = 0; k < introns_info.length; k++)
    		table_text.push(introns_info[k]);
    
    //se exons_info Ã¨ NULL significa che il click Ã¨ stato fatto
    //sopra un introne
    if(exons_info != null){
    //esoni e introni selezionati
    var g = s_i.append("g")
        .attr("id", "regions_selected")
        .attr("transform", transf.tf_g);        
    g.selectAll("rect")
        .data(exons_info)
        .enter().append("rect")
        .attr("id", function(d) { return "r_e_" + d.id; })
        .attr("width", function(d) { return x_iso(d.end) - x_iso(d.start); })
        .attr("height", 40)
        .style("fill", color_exon)
        .style("stroke", function(d){ 
        					if(d.annotated == true)
        						return d3.rgb("#00008B");
        					else
        						return d3.rgb("white");
        					})
        .style("stroke-width", "3px")			
        .style("opacity", "0.0")
        .attr("transform", transf.t_e)
        .on("mouseover", function(d) { 
                            d3.select(this).style('cursor', 'context-menu');
                            //esone selezionato nella struttura
                            var s = element_selected_exon(r, x_iso(d.start), x_iso(d.end));
                            
                            seq_id = "#sequence_ex_" + d.id;
                            //sequenza nucleotidica corrispondente
                            var t = d3.select(seq_id);
                            t.style("fill", "#428bca");
                            connect_exon(s, t);
                            d3.selectAll("#text_" + d.id)
                            	.style("fill", "#428bca");
                            
                            })
        .on("mouseout", function(d) { 
                            d3.select(this).style('cursor', 'default');
                            
                            //elimina la selezione
                            d3.select("#element_info_exon").remove();
                            
                            seq_id = "#sequence_ex_" + d.id;
                            d3.select(seq_id).style("fill", "black");
                            //elimina i link 
                            d3.selectAll(".link").remove();
                            d3.selectAll("#text_" + d.id)
                            	.style("fill", "black");
                           })
        .on("click", function(d) {
        	        	
        	        	//aggiunge i dati che saranno visualizzati nella
        	        	//finestra modale			
        				d3.select("#modal_body").selectAll("p")
        					.remove();
        						
        				d3.select("#modal_t").selectAll("h4")
        					.remove();
        				
        				d3.select("#modal_t").append("h4")
        					.attr("class", "modal-title")
        					.text("Exon: " + d.id);
        				d3.select("#modal_body").append("p")
        					//recupero dei valori originali
        					.text("Start: " + o_s.exons[d.id].start);
        				d3.select("#modal_body").append("p")
        					.text("End: " + o_s.exons[d.id].end);
        				d3.select("#modal_body").append("p")
        					.text("Length: " + o_s.exons[d.id].length);
        					
        				d3.select("#modal_body").append("p")
        					.text("Annotated: " + d.annotated);
        				
        				d3.select("#modal_body").append("p")
        					.text("Alternative: " + d.alternative);
        				
       					$("#myModal").modal('show');
       					
       			 	})
        .transition()
        .duration(750)
        .style("opacity","1.0");
    }
    //se introns_info Ã¨ NULL nella selezione non sono presenti introni
    if(introns_info != null){
    	g.selectAll("line")
    		.data(introns_info)
			.enter().append("line")
			.attr("id", function(d) { return "i_e_" + d.id; })
			.attr("x1", function(d) { return x_iso(d.start); })
			.attr("y1", 35)
			.attr("x2", function(d) { 
							if((x_iso(d.end) - x_iso(d.start)) < 10)
								return x_iso(d.end) + 40;
							else
								return x_iso(d.end); })
			.attr("y2", 35)
			.attr("transform", transf.t_i)
			.style("stroke", color_intron)
			.style("stroke-width", 10)
			.style("opacity", "0.0")
            .on("mouseover", function(d, i) { 
                                d3.select(this).style('cursor', 'context-menu');
                                //traslazione testo pattern
                                var tf_info_text = d3.svg.transform()
                                    .translate(function () { 
                                        return [0, (i * 20) + (exons_info.length * 45)]; });
                                
                                //aggiunta del pattern agli estremi dell'introne    
                                g.append("text")
                                    .attr("x", x_iso(d.start) - 15)
                                    .attr("y", 38)
                                    .style("font-size", "10px")
                                    .attr("transform", tf_info_text)
                                    .style("font-family", "Arial, Helvetica, sans-serif")
                                    .style("fill", "#428bca")
                                    .text(d.pattern.slice(0,2).toUpperCase());
                                g.append("text")
                                    .attr("x", x_iso(d.end))
                                    .attr("y", 38)
                                    .style("font-size", "10px")
                                    .style("font-family", "Arial, Helvetica, sans-serif")
                                    .attr("transform", tf_info_text)
                                    .style("fill", "#428bca")
                                    .text(d.pattern.slice(2,4).toUpperCase());
                                
                                //elemento selezionato sulla struttura genica    
                                var s = element_selected_intron(x_iso(d.start), x_iso(d.end));
                                //sequenza nucleotidica
                                seq_id = "#sequence_in_" + d.id;
                                var t = d3.select(seq_id);
                                t.style("fill", "#428bca");
                                //link
                                connect_intron(s, t);
                                d3.selectAll("#text_" + d.id)
                            		.style("fill", "#428bca"); })
            .on("mouseout", function(d) { 
            					//rimozione elemento selezionato
                                d3.select(this).style('cursor', 'default');
                                d3.select("#element_info_intron").remove();
                                
                                //rimozione sequenza nucleotidica
                                seq_id = "#sequence_in_" + d.id;
                                d3.select(seq_id).style("fill", "black");
                                g.selectAll("text").remove();
                                
                                //rimozione link
                                d3.selectAll(".link").remove();
                                d3.selectAll("#text_" + d.id)
                            		.style("fill", "black"); })
            .on("click", function(d) {
            					
            					//aggiunge i dati che verrano visualizzati
            					//nella finestra modale
        						d3.select("#modal_body").selectAll("p")
        							.remove();
        						d3.select("#modal_t").selectAll("h4")
        							.remove();
        				
        						d3.select("#modal_t").append("h4")
        							.attr("class", "modal-title")
        							.text("Intron: " + d.id);
        						//recupero dei dati originali
        						d3.select("#modal_body").append("p")
        							.text("Start: " + o_s.introns[d.id].start);
        						d3.select("#modal_body").append("p")
        							.text("End: " + o_s.introns[d.id].end);
        						d3.select("#modal_body").append("p")
        							.text("Length: " + o_s.introns[d.id].length);
        							
        						d3.select("#modal_body").append("p")
        							.append("text")
        							.text("Prefix: ")
        							.append("text")
        							.attr("class", "text-primary")
        							.text(d.prefix.substring(0,2).toUpperCase())
        							.append("text")
        							.attr("class", "text-seq")
        							.text(d.prefix.substring(2,d.prefix.length).toUpperCase());
        						d3.select("#modal_body").append("p")
        							.append("text")
        							.text("Suffix: ")
        							.append("text")
        							.attr("class", "text-seq")
        							.text(d.suffix.substring(0,d.suffix.length-3).toUpperCase())
        							.append("text")
        							.attr("class", "text-primary") 
        							.text(d.suffix.substring(d.suffix.length-2,d.suffix.length).toUpperCase());
        						
       							$("#myModal").modal('show');
       			 		})
            .transition()
        	.duration(750)
        	.style("opacity","1.0");
	} 
	
	//aggiunge della tabella
	var table_title = s_i.append("g")
        .attr("id", "table_title")
        .attr("transform", transf.tf_table_title)
        .attr("visibility", "visible");
    
    table_title.append("text")
    	.attr("x", column_start)
    	.attr("y", 15)
    	.style("font-size", "16px")
    	.style("font-family", "Arial, Helvetica, sans-serif")
    	.style("fill", "blue")
    	.text("Start")
    	.style("opacity", "0.0")
        .transition()
        .duration(750)
        .style("opacity","1.0");
    
    table_title.append("text")
    	.attr("x", column_end)
    	.attr("y", 15)
    	.style("font-size", "16px")
    	.style("font-family", "Arial, Helvetica, sans-serif")
    	.style("fill", "blue")
    	.text("End")
    	.style("opacity", "0.0")
        .transition()
        .duration(750)
        .style("opacity","1.0");
    table_title.append("line")
    	.attr("x1", 20)
    	.attr("y1", 20)
    	.attr("x2", 260)
    	.attr("y2", 20)
    	.style("stroke", "black")
    	.style("stroke-width", "1px")
    	.style("opacity", "0.0")
        .transition()
        .duration(750)
        .style("opacity","1.0");
    	
    var table_start = s_i.append("g")
        .attr("id", "table_start")
        .attr("transform", transf.tf_table_start)
        .attr("visibility", "visible");
	
	table_start.selectAll("text")
    	.data(table_text)
    	.enter().append("text")
    	.attr("id", function(d) { return "text_" + d.id; })
    	.attr("x", function(d, i) { return (column_start - (d.start.toString().length)); })
    	.attr("y", function(d) { 
    					if(d.pattern != null)
    						return 25;
    					else
    						return 15; })
    	.attr("transform", function(d, i) { 
    						//la posizione del testo della tabella viene recuperata
    						//dall'elemento a cui corrisponde con l'attributo "transform"
    						if(d.pattern == null)
    							return "translate(0," +  i * 45 + ")";
    						else
    							return d3.select("#i_e_" + d.id).attr("transform"); 
    						})
    	.style("font-size", "16px")
    	.style("font-family", "Arial, Helvetica, sans-serif")
    	.style("fill", "black")
    	.text(function(d) { 
    			//recupero dei valori originali
    			if(d.pattern == null)
    				return o_s.exons[d.id].start;
    			else
    				return o_s.introns[d.id].start; })
    	.style("opacity", "0.0")
        .transition()
        .duration(750)
        .style("opacity","1.0");
    
    var table_end = s_i.append("g")
        .attr("id", "table_end")
        .attr("transform", transf.tf_table_end)
        .attr("visibility", "visible");
    
    table_end.selectAll("text")
    	.data(table_text)
    	.enter().append("text")
    	.attr("id", function(d) { return "text_" + d.id; })
    	.attr("x", function(d,i) { return (column_end - (d.start.toString().length)); })
    	.attr("y", function(d) { 
    					if(d.pattern != null)
    						return 25;
    					else
    						return 15; })
    	.attr("transform", function(d, i) { 
    						//la posizione del testo della tabella viene recuperata
    						//dall'elemento a cui corrisponde con l'attributo "transform"
    						if(d.pattern == null)
    							return "translate(0," +  i * 45 + ")";
    						else
    							return d3.select("#i_e_" + d.id).attr("transform"); 
    						})
    	.style("font-size", "16px")
    	.style("font-family", "Arial, Helvetica, sans-serif")
    	.style("fill", "black")
    	.text(function(d) { 
    			//recupero dei valori originali
    			if(d.pattern == null)
    				return o_s.exons[d.id].end;
    			else
    				return o_s.introns[d.id].end; })
    	.style("opacity", "0.0")
        .transition()
        .duration(750)
        .style("opacity","1.0");
}


/* DISPLAY_INFO_STRIPE
 * s_i -> finestra creata per visualizzare le informazioni
 * x_iso -> dominio della finestra di visualizzazione degli elementi
 * elements -> elementi estratti dalla struttura del gene
 *             in base alla selezione.
 * r -> contenitore degli esoni
 * 
 * Visualizza gli elementi, appartenenti alla selezione sulla struttura genica, 
 * nella finestra della struttura espansa (per esoni 'conservative').
 * La funzione esegue le stesse operazioni di "display_info" ma viene lanciata 
 * al click sopra un esone 'conservative' (esone con texture).
 */     
function display_info_stripe(s_i, x_iso, elements, r){
    
    //elementi estratti dalla selezione
    var exons_info = elements.r_i;
    var introns_info = elements.i_i;
    
    //posizione e dimensione della tabella
    var start_table = s_w - width_isoform + margin_isoform.left + margin_isoform.right;
    var column_start = 50, column_end = 200;
    
    //colori degli elementi
    var color_exon = function() { return d3.rgb("#ADD8E6"); };
    var color_intron = function() { return d3.rgb("black"); };
    
    var transf = {	
    	//traslazione esoni   
   		t_e : d3.svg.transform()
        	.translate(function (d, i) { return [x_iso(d.start), i * 45]; }),
        //traslazione introni
    	t_i : d3.svg.transform()
        	.translate(function (d, i) { return [0, (i * 20) + (exons_info.length * 45)]; }),
        //traslazione contenitore elementi 
    	tf_g : d3.svg.transform()
        	.translate(function (d, i) { return [15, 20]; }),
           tf_table_title : d3.svg.transform()
            .translate(function (d, i) { return [start_table, 0]; }),
        tf_table_start : d3.svg.transform()
            .translate(function (d, i) { return [start_table, 35]; }),
        tf_table_end : d3.svg.transform()
            .translate(function (d, i) { return [start_table, 35]; })
       };
       
    //esoni
    var g = s_i.append("g")
        .attr("id", "regions_selected")
        .attr("transform", transf.tf_g);        
    g.selectAll("rect")
        .data(exons_info)
        .enter().append("rect")
        .attr("width", function(d) { return x_iso(d.end) - x_iso(d.start); })
        .attr("height", 40)
        .style("fill", color_exon)
        .style("stroke", function(d){ 
        					if(d.annotated == true)
        						return d3.rgb("#00008B");
        					else
        						return d3.rgb("white");
        					})
        .style("stroke-width", "3px")
        .style("opacity", "0.0")
        .attr("transform", transf.t_e)
        .on("mouseover", function(d) { 
        					d3.select(this).style('cursor', 'context-menu');
                            var s = element_selected_exon(r, x(d.start), x(d.end)); 
                            
                            seq_id = "#sequence_ex_" + d.id;
                            var t = d3.select(seq_id);
                            t.style("fill", "#428bca");
                            connect_exon(s, t);
                            d3.selectAll("#text_" + d.id)
                            	.style("fill", "#428bca");})
        .on("mouseout", function(d) { 
        					d3.select(this).style('cursor', 'default');
        					d3.select("#element_info_exon").remove();
        					
        					seq_id = "#sequence_ex_" + d.id;
                            d3.select(seq_id).style("fill", "black");
                            d3.selectAll(".link").remove();
                            d3.selectAll("#text_" + d.id)
                            	.style("fill", "black"); })
        .on("click", function(d) {
        				d3.select("#modal_body").selectAll("p")
        					.remove();
        						
        				d3.select("#modal_t").selectAll("h4")
        					.remove();
        				
        				d3.select("#modal_t").append("h4")
        					.attr("class", "modal-title")
        					.text("Exon: " + d.id);
        				d3.select("#modal_body").append("p")
        					.text("Start: " + o_s.exons[d.id].start);
        				d3.select("#modal_body").append("p")
        					.text("End: " + o_s.exons[d.id].end);
        				d3.select("#modal_body").append("p")
        					.text("Length: " + o_s.exons[d.id].length);
        				d3.select("#modal_body").append("p")
        					.text("Annotated: " + d.annotated);
        				
        				d3.select("#modal_body").append("p")
        					.text("Alternative: " + d.alternative);
        					
       					$("#myModal").modal('show');
       			 	})
        .transition()
        .duration(750)
        .style("opacity","1.0");
    
    //introni    
    if(introns_info != null){
    	g.selectAll("line")
    		.data(introns_info)
			.enter().append("line")
			.attr("id", function(d) { return "i_e_" + d.id; })
			.attr("x1", function(d) { return x_iso(d.start); })
			.attr("y1", 35)
			.attr("x2", function(d) { 
							if((x_iso(d.end) - x_iso(d.start)) < 10)
								return x_iso(d.end) + 40;
							else
								return x_iso(d.end); })
			.attr("y2", 35)
			.attr("transform", transf.t_i)
			.style("stroke", color_intron)
			.style("stroke-width", 8)
			.style("opacity", "0.0")
			.on("mouseover", function(d, i) { 
                                d3.select(this).style('cursor', 'context-menu');
                                var s = element_selected_intron(x(d.start), x(d.end));

                                var tf_info_text = d3.svg.transform()
                                    .translate(function () { 
                                        return [0, (i * 20) + (exons_info.length * 45)]; });
                                    
                                g.append("text")
                                    .attr("x", x_iso(d.start) - 15)
                                    .attr("y", 38)
                                    .attr("font-size", "10px")
                                    .attr("transform", tf_info_text)
                                    .style("fill", "#428bca")
                                    .text(d.pattern.slice(0,2).toUpperCase());
                                g.append("text")
                                    .attr("x", x_iso(d.end))
                                    .attr("y", 38)
                                    .attr("font-size", "10px")
                                    .attr("transform", tf_info_text)
                                    .style("fill", "#428bca")
                                    .text(d.pattern.slice(2,4).toUpperCase());
                                    
                                seq_id = "#sequence_in_" + d.id;
                                var t = d3.select(seq_id);
                                t.style("fill", "#428bca");
                                connect_intron(s, t);
                                d3.selectAll("#text_" + d.id)
                            	.style("fill", "#428bca"); })
            .on("mouseout", function(d) { 
                                d3.select(this).style('cursor', 'default');
                                d3.select("#element_info_intron").remove();
                                seq_id = "#sequence_in_" + d.id;
                                d3.select(seq_id).style("fill", "black");
                                g.selectAll("text").remove();
                                d3.selectAll(".link").remove();
                                d3.selectAll("#text_" + d.id)
                            	.style("fill", "black"); })
            .on("click", function(d) {
        						d3.select("#modal_body").selectAll("p")
        							.remove();
        						d3.select("#modal_t").selectAll("h4")
        							.remove();
        				
        						d3.select("#modal_t").append("h4")
        							.attr("class", "modal-title")
        							.text("Intron: " + d.id);
        						d3.select("#modal_body").append("p")
        							.text("Start: " + o_s.introns[d.id].start);
        						d3.select("#modal_body").append("p")
        							.text("End: " + o_s.introns[d.id].end);
        						d3.select("#modal_body").append("p")
        							.text("Length: " + o_s.introns[d.id].length);
        						d3.select("#modal_body").append("p")
        							.append("text")
        							.text("Prefix: ")
        							.append("text")
        							.attr("class", "text-primary")
        							.text(d.prefix.substring(0,2).toUpperCase())
        							.append("text")
        							.attr("class", "text-seq")
        							.text(d.prefix.substring(2,d.prefix.length).toUpperCase());
        						d3.select("#modal_body").append("p")
        							.append("text")
        							.text("Suffix: ")
        							.append("text")
        							.attr("class", "text-seq")
        							.text(d.suffix.substring(0,d.suffix.length-3).toUpperCase())
        							.append("text")
        							.attr("class", "text-primary") 
        							.text(d.suffix.substring(d.suffix.length-2,d.suffix.length).toUpperCase());
        							
       							$("#myModal").modal('show');
       			 		})
            .transition()
        	.duration(750)
        	.style("opacity","1.0");   
	}   
	
	var o_s = {
		exons : original_structure(original_regions, 'exon'),
		introns: original_structure(original_regions, 'intron')
	};  
	
    var table_text = [];
    for(k = 0; k < exons_info.length; k++)
        table_text.push(exons_info[k]);
    if(introns_info != null)
        for(k = 0; k < introns_info.length; k++)
            table_text.push(introns_info[k]);
       
    var table_title = s_i.append("g")
        .attr("id", "table_title")
        .attr("transform", transf.tf_table_title)
        .attr("visibility", "visible");
    
    table_title.append("text")
        .attr("x", column_start)
        .attr("y", 15)
        .style("font-size", "16px")
        .style("font-family", "Arial, Helvetica, sans-serif")
        .style("fill", "blue")
        .text("Start")
        .style("opacity", "0.0")
        .transition()
        .duration(750)
        .style("opacity","1.0");
    
    table_title.append("text")
        .attr("x", column_end)
        .attr("y", 15)
        .style("font-size", "16px")
        .style("font-family", "Arial, Helvetica, sans-serif")
        .style("fill", "blue")
        .text("End")
        .style("opacity", "0.0")
        .transition()
        .duration(750)
        .style("opacity","1.0");
    table_title.append("line")
        .attr("x1", 20)
        .attr("y1", 20)
        .attr("x2", 260)
        .attr("y2", 20)
        .style("stroke", "black")
        .style("stroke-width", "1px")
        .style("opacity", "0.0")
        .transition()
        .duration(750)
        .style("opacity","1.0");
        
    var table_start = s_i.append("g")
        .attr("id", "table_start")
        .attr("transform", transf.tf_table_start)
        .attr("visibility", "visible");
    
    table_start.selectAll("text")
        .data(table_text)
        .enter().append("text")
        .attr("id", function(d) { return "text_" + d.id; })
    	.attr("x", function(d,i) { return (column_start - (d.start.toString().length)); })
    	.attr("y", function(d) { 
    					if(d.pattern != null)
    						return 25;
    					else
    						return 15; })
    	.attr("transform", function(d, i) { 
    						
    						if(d.pattern == null)
    							return "translate(0," +  i * 45 + ")";
    						else
    							return d3.select("#i_e_" + d.id).attr("transform"); 
    						})
        .style("font-size", "16px")
        .style("font-family", "Arial, Helvetica, sans-serif")
        .style("fill", "black")
        .text(function(d) { 
                if(d.pattern == null)
                    return o_s.exons[d.id].start;
                else
                    return o_s.introns[d.id].start; })
        .style("opacity", "0.0")
        .transition()
        .duration(750)
        .style("opacity","1.0");
    
    var table_end = s_i.append("g")
        .attr("id", "table_end")
        .attr("transform", transf.tf_table_end)
        .attr("visibility", "visible");
    
    table_end.selectAll("text")
        .data(table_text)
        .enter().append("text")
        .attr("id", function(d) { return "text_" + d.id; })
        .attr("x", function(d,i) { return (column_end - (d.start.toString().length)); })
    	.attr("y", function(d) { 
    					if(d.pattern != null)
    						return 25;
    					else
    						return 15; })
    	.attr("transform", function(d, i) { 
    						
    						if(d.pattern == null)
    							return "translate(0," +  i * 45 + ")";
    						else
    							return d3.select("#i_e_" + d.id).attr("transform"); 
    						})
        .style("font-size", "16px")
        .style("font-family", "Arial, Helvetica, sans-serif")
        .style("fill", "black")
        .text(function(d) { 
                if(d.pattern == null)
                    return o_s.exons[d.id].end;
                else
                    return o_s.introns[d.id].end; })
        .style("opacity", "0.0")
        .transition()
        .duration(750)
        .style("opacity","1.0");
}


/* PATTERN_EXONS
 * 
 * Definisce un pattern a strisce per differenziare la tipologia
 * degli esoni.
 */                
function pattern_exons(){
    
    defs = d3.select("body").append("svg")
        .append('defs');
    defs.append('defs')
        .append('pattern')
        .attr('id', 'diagonalHatch')
        .attr('patternUnits', 'userSpaceOnUse')
        .attr('width', 4)
        .attr('height', 4)
        .append('path')
        .attr('d', 'M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2')
        .attr('stroke', '#000000')
        .attr('stroke-width', 1.5);
}


/* CHECK_STRUCTURE_ELEMENT
 * regions_info -> vettore che contiene l'id della regione
 *                 selezionata con il mouse
 * c -> coordinate(mouse) della selezione
 * r_e -> contenitore degli esoni
 * 
 * Crea una struttura di esoni e introni in base
 * alle coordinate della selezione. Restituisce una struttura contenente
 * gli array degli esoni e introni trovati.
 */
function check_structure_element(regions_ext, c, r_e){
		
    //elementi che verranno estratti dalla selezione 
    var element = {
    	r_i : [],
    	i_i : [],
    };
    //contenitore degli splice sites da evidenziare
    splice_select = [];
	var s, e;
    
    //il click della selezione Ã¨ stato fatto sopra un esone
    if(flag_exon == true){
    	//ricerca gli esoni contengono la regione
    	for(re = 0; re < exons_restruct.length; re++)
    		for(ra = 0; ra < exons_restruct[re].regions.length; ra++)
    			if(regions_ext.id == exons_restruct[re].regions[ra])
        			element.r_i.push(exons_restruct[re]);
    	
    	//rimuove i duplicati tra gli esoni trovati
    	element.r_i = remove_duplicate(element.r_i);
    }
        
    //ricerca degli introni
    for(i = 0; i < introns_restruct.length; i++)
    	for(ra = 0; ra < introns_restruct[i].regions.length; ra++){
			if(+regions_ext.id == introns_restruct[i].regions[ra])            
				element.i_i.push(introns_restruct[i]);
        d3.select("#i_e_" + introns_restruct[i].id).remove();
    	}
    element.i_i = remove_duplicate(element.i_i);

    //elementi.i_i Ã¨ NULL se nella selezione non sono presenti gli introni
    if(element.i_i != null){
		for(rs = 0; rs < element.i_i.length; rs++)
    		r_e.append("line")
				.attr("id", "intron_s")
				.attr("x1", function(d) { return x(element.i_i[rs].start); })
				.attr("y1", 35)
				.attr("x2", function(d) { return x(element.i_i[rs].end); })
				.attr("y2", 35)
				.style("stroke", "black")
				.style("stroke-width", 6);
		//selezione degli splice sites corrispondenti alle coordinate
		for(l = 0; l < element.i_i.length; l++){
			s = element.i_i[l].start;
			sl = element.i_i[l].start - 1;
			e = element.i_i[l].end;
			em = element.i_i[l].end + 1;
			for(h = 0; h < s_s_restruct.length; h++){
				if((s_s_restruct[h].position == s) | (s_s_restruct[h].position == e))
					splice_select.push(s_s_restruct[h]);
				if((s_s_restruct[h].position == sl) | (s_s_restruct[h].position == em))
					splice_select.push(s_s_restruct[h]);
			}
		}
	}
    
    if(element.r_i != null){
    	//elementi selezionati evidenziati sulla struttura genica
    	for(rs = 0; rs < element.r_i.length; rs++)
    		r_e.append("rect")
				.attr("id", "exon_s")
				.attr("x", x(element.r_i[rs].start))
        		.attr("y", 0)
				.attr("width", function() { return x(element.r_i[rs].end) - x(element.r_i[rs].start) - 1; })
				.attr("height", "75")
				.attr("rx", 3)
				.attr("ry", 3)
				.style("fill", function() {	return d3.rgb("#228B22"); });
	
		//selezione degli splice sites corrispondenti alle coordinate
		for(l = 0; l < element.r_i.length; l++){
			s = element.r_i[l].start;
			sl = element.r_i[l].start - 1;
			e = element.r_i[l].end;
			em = element.r_i[l].end + 1;
			for(h = 0; h < s_s_restruct.length; h++){
				if((s_s_restruct[h].position == s) | (s_s_restruct[h].position == e))
					splice_select.push(s_s_restruct[h]);
				if((s_s_restruct[h].position == sl) | (s_s_restruct[h].position == em))
					splice_select.push(s_s_restruct[h]);
			}
		}
	}
	
	splice_select = remove_duplicate(splice_select);
	
	for(l = 0; l < splice_select.length; l++){
		d3.select("#s_s_" + splice_select[l].id)
			.style("stroke-width", "1.5px")
			.style("stroke", d3.rgb("blue").brighter(3));
		d3.select("#up_" + (splice_select[l].id))
            .style("stroke", "black");
        d3.select("#down_" + (splice_select[l].id))
        	.style("stroke", "black");
	}       
	
    return element;   
}

/* MOUSE_POS
 * xm -> coordinata sull'assse X del mouse
 * ym -> coordinata sull'asse Y del mouse
 * 
 * Aggiunge un segnalatore nel punto in cui Ã¨ avvenuto il click del mouse.
 */
function mouse_pos(xm, ym){
	
	d3.selectAll("#cross_pos").remove();
	
	svg_isoform.append("path")
		.attr("id", "cross_pos")
    	.attr("transform", function(d) { return "translate(" + xm + "," + ym + ")"; })
    	.attr("d", d3.svg.symbol().type("cross"))
    	.style("fill", "yellow");
}

/* DRAW_EXONS
 * box -> contenitore dell'isoforma
 * exons -> struttura dati degli esoni
 * x_scale -> variabile che contiente la funzione per il range e il dominio di
 * 			  visualizzazione
 * 
 * Disegna gli esoni differenziandoli in base al campo "alternative". In base
 * alla posizione del mouse e all'evento connesso ad esso, richiama le funzioni 
 * per la visualizzazione degli elementi selezionati.
 */
function draw_exons(box, exons, x_scale){
	
	//array per gli esoni "conservative"
	var exons_stripe = [];
	//altezza esoni
	var exons_h = 75;
	
	//colori per gli elementi
	var color_exon = function() { return d3.rgb("#228B22"); };
	var color_exon_after = function() { return d3.rgb("#D3D3D3"); };
    var color_intron = function() { return d3.rgb("black"); };
    var color_intron_after = function() { return d3.rgb("#D3D3D3"); };
	
	//vettore di esoni 'conservative'
	for(k = 0; k < exons.length; k++)
	   if(exons[k].alternative == false)
	       exons_stripe.push(exons[k]);
    	  			  	
	//variabile per traslare gli esoni
	var tf = d3.svg.transform()
		.translate(function (d) { return [x_scale(d.start), 0]; });
	
	//contenitore degli esoni 'alternative'
	var rect_exons = box.append("g")
		.attr("id", "exons")
		.attr("transform", "translate(" + margin_isoform.left + "," + margin_isoform.top/2 + ")");
	//aggiunge i blocchi "esoni"
	rect_exons.selectAll("rect")
		.data(exons)
		.enter()
		.append("rect")
		.attr("id", "exon")
		.attr("width", function(d) { return x_scale(d.end) - x_scale(d.start) - 1; })
		.attr("height", "0")
		.attr("rx", 3)
		.attr("ry", 3)
		.style("fill", color_exon)
		.style("opacity", 1.0)
		.attr("transform",tf)
		.on("click", function(d){ 
					   
					   //aggiorna la selezione
					   if(flag_structure == true){
					      d3.selectAll("#exon_s")
					      	.remove();	
					      d3.selectAll("#intron_s")
					      	.remove();				
					   }
					   
					   //selezione sopra esoni 'alternative'	 	   
		               if(d.alternative == true){
		               	  //colora di grigio la struttura per evidenziare la selezione
		                  d3.selectAll("#exon")
						    .style("fill", color_exon_after);
						  d3.selectAll("#intron")
                            .style("stroke", color_intron_after);
                          for(s = 0; s < s_s_restruct.length; s++)
                          	d3.select("#up_" + s)
                            	.style("stroke", color_intron_after);
                          for(s = 0; s < s_s_restruct.length; s++)
                          	d3.select("#down_" + s)
                            	.style("stroke", color_intron_after);
                          
                          //ripristina gli splice sites
                          for(s = 0; s < s_s_restruct.length; s++)
                          	d3.select("#s_s_" + s_s_restruct[s].id)
                            	.style("stroke", color_intron_after)
                            	.style("stroke-width", "1px");
                          									
						  //coordinate della posizione del mouse al momento del "click"
						  var coord_x = x_scale.invert(d3.event.pageX - 25);
						  //sottrae i valori della traslazione
						  var xc = d3.event.pageX - 15;
						  var yc = d3.event.pageY - 60;
						  mouse_pos(xc, yc);
						  
						  //funzioni per gli elementi selezionati
						  var regions = regions_select(coord_x);
						  flag_exon = true;					  
						  info_structure = check_structure_element(regions, coord_x, rect_exons);  	
						  display_info(svg_expande, x_scale, info_structure, rect_exons);
						  sequence_box(box, info_structure);
						      
        			      }
        			    flag_structure = true; })							  		
		.on("mouseover", function() { d3.select(this).style('cursor', 'cell'); })
		.on("mouseout", function() { d3.select(this).style('cursor', 'default'); })
	    .transition()
	    .duration(750)
	    .attr("height", exons_h);
	
	//esoni 'conservated'							 
	var rect_exons_stripe = box.append("g")
        .attr("id", "exons_stripes")
        .attr("transform", "translate(" + margin_isoform.left + "," + margin_isoform.top/2 + ")");
    //aggiunge i blocchi per gli esoni 'conservated'
    rect_exons_stripe.selectAll("rect")
        .data(exons_stripe)
        .enter()
        .append("rect")
        .attr("id", "exon_stripe")
        .attr("width", function(d) { return x_scale(d.end) - x_scale(d.start) - 1; })
        .attr("height", "0")
        .attr("rx", 3)
		.attr("ry", 3)
		//applica la texture a strisce
        .style("fill", 'url(#diagonalHatch)')
        .attr("transform",tf) 
        .on("click", function(d){ 
        				
        				//aggiorna la selezione
        				if(flag_structure == true){
					      d3.selectAll("#exon_s")
					      	.remove();
					      d3.selectAll("#intron_s")
					      	.remove();
					    }
        				
        				//colora di grigio la struttura per evidenziare
        				//la selezione degli elementi
                        d3.selectAll("#exon")
                          .style("fill", color_exon_after);
                        d3.selectAll("#intron")
                            .style("stroke", color_intron_after);
                        for(s = 0; s < s_s_restruct.length; s++)
                          	d3.select("#up_" + s)
                            	.style("stroke", color_intron_after);
                        for(s = 0; s < s_s_restruct.length; s++)
                          	d3.select("#down_" + s)
                            	.style("stroke", color_intron_after); 
                        
                        //ripristina gli splice sites    
                        for(s = 0; s < s_s_restruct.length; s++)
                          	d3.select("#s_s_" + s_s_restruct[s].id)
                            	.style("stroke", color_intron_after)
                            	.style("stroke-width", "1px");
                         
        		        //coordinate della posizione del mouse al momento del "click"       
                        var coord_x = x_scale.invert(d3.event.pageX - 25);
                        var xc = d3.event.pageX - 15;
						var yc = d3.event.pageY - 60;
						mouse_pos(xc, yc);
						
						//funzioni per gli elementi selezionati  
						var regions = regions_select(coord_x);
						flag_exon = true;
                       	info_structure = check_structure_element(regions, coord_x, rect_exons);  
                        display_info_stripe(svg_expande, x_scale, info_structure, rect_exons_stripe);
                        sequence_box(box, info_structure);
                        
						flag_structure = true; })                           
        .on("mouseover", function() { d3.select(this).style('cursor', 'cell'); })
        .on("mouseout", function() { d3.select(this).style('cursor', 'default'); })
        .transition()
        .duration(750)
        .attr("height", exons_h);
          		
	return rect_exons;	
}


/* DRAW_INTRONS
 * box -> contenitore dell'isoforma
 * introns -> struttura dati degli introni
 * x_scale -> variabile che contiente la funzione per il range e il dominio di
 * 			  visualizzazione
 * 
 * Disegna gli introni. In base
 * alla posizione del mouse e all'evento connesso ad esso, richiama le funzioni 
 * per la visualizzazione degli elementi selezionati.
 */
function draw_introns(box, introns, x_scale){
    
    //colori per gli elementi
	var color_exon = function() { return d3.rgb("#228B22"); };
	var color_exon_after = function() { return d3.rgb("#808080"); };
    var color_intron = function() { return d3.rgb("black"); };
    var color_intron_after = function() { return d3.rgb("#808080"); };
    
    //contenitore degli introni
	var line_introns = box.append("g")
		.attr("id", "introns")
		.attr("transform", "translate(" + margin_isoform.left + "," + margin_isoform.top/2 + ")");
		
	line_introns.selectAll("line")
		.data(introns)
		.enter().append("line")
		.attr("id", "intron")
		.attr("x1", function(d) { return x(d.start); })
		.attr("y1", 35)
		.attr("x2", function(d) { return x(d.start); })
		.attr("y2", 35)
		.style("stroke", color_intron)
		.style("stroke-width", 6)
		.on("click", function(d){
			
						if(flag_structure == true){
					      d3.selectAll("#exon_s")
					      	.remove();	
					      d3.selectAll("#intron_s")
					      	.remove();				
					   }
					   	
					   	//colora di grigio la struttura per evidenziare
					   	//la selezione degli elementi 	   
		                d3.selectAll("#exon")
						    .style("fill", color_exon_after);
						d3.selectAll("#intron")
                            .style("stroke", color_intron_after);
                        for(s = 0; s < s_s_restruct.length; s++)
                          	d3.select("#up_" + s)
                            	.style("stroke", color_intron_after);
                        for(s = 0; s < s_s_restruct.length; s++)
                          	d3.select("#down_" + s)
                            	.style("stroke", color_intron_after);
                          
                        for(s = 0; s < s_s_restruct.length; s++)
                          	d3.select("#s_s_" + s_s_restruct[s].id)
                            	.style("stroke", color_intron_after)
                            	.style("stroke-width", "1px");
                                                   
                        //coordinate della posizione del mouse al momento del "click"
						var coord_x = x_scale.invert(d3.event.pageX - 25);
						var xc = d3.event.pageX - 15;
						var yc = d3.event.pageY - 60;
						mouse_pos(xc, yc);
						  
						//funzioni per gli elementi selezionati
						var regions = regions_select(coord_x);		
						flag_exon = false;			  
						info_structure = check_structure_element(regions, coord_x, line_introns);  	
						display_info(svg_expande, x_scale, info_structure, line_introns, x_scale);
						sequence_box(box, info_structure);
						
						})
		.on("mouseover", function() { d3.select(this).style('cursor', 'cell'); })
		.on("mouseout", function() { d3.select(this).style('cursor', 'default'); })
		.transition()
		.delay(750)
		.duration(750)
		.attr("x2", function(d) { return x(d.end); });
			
	return line_introns;
}


/* CLONE_SVG_ELEMENT (DEPRECATED)
 * svg -> variabile che contiene l'elemento "svg"
 * obj -> oggetto da clonare
 * 
 * Clona l'oggetto contenuto in "obj" e lo aggiunge alla finestra di 
 * visualizzazione contenuta nella variabile "svg".
 * Il contenitore "g" del "segnale alto" della tipologia degli splice sites 
 * viene clonato e riutilizzato per aggiungere un "segnale basso".
 * Il tag <use> in Safari e Chrome non viene renderizzato istantaneamente.
 */
function clone_svg_element(svg, obj) {
	
	var triangle_down = svg.append("use")
    	.attr("xlink:xlink:href","#" + obj.attr("id"));
    return triangle_down;
}


/* DRAW_SPLICE_SITES
 * box -> variabile che contiente l'elemento "svg"
 * s_s -> struttura dati degli splice sites
 * x_scale -> variabile che contiente la funzione per il range e il dominio di
 * 			  visualizzazione
 * 
 * Disegna gli splice sites e i segnali che ne indicano la tipologia.
 */
function draw_splice_sites(box, s_s, x_scale){
		
	var color_s_s = function() { return d3.rgb("black"); };
		
	//variabile per i simboli della tipologia 
	//degli splice sites
	var s_sy = d3.svg.symbol()
		.type('triangle-up')
		.size(20);
					
	//contenitore degli splice sites
	var splice_sites = box.append("g")
		.attr("id", "splice_sites")
		.attr("transform", "translate(" + margin_isoform.left + "," + margin_isoform.top/2 + ")");
	
	//aggiunge le linee che rappresentano gli splice sites	
	splice_sites.selectAll("line")
		.data(s_s)
		.enter().append("line")
		.attr("id", function(d) { return "s_s_" + d.id; })
		.attr("x1", function(d) { if(d.position != null) 
									return x_scale(d.position); })
		.attr("y1", -30)
		.attr("x2", function(d) { if(d.position != null)
									return x_scale(d.position); })
		.attr("y2", 110)
		.style("opacity", "0.0")
		.style("stroke", color_s_s)
		.style("strole-width", "2px")
		.style("stroke-dasharray", function(d) { 
									  //differenziazione degli splice sites
		                              if ((d.type == "init") | (d.type == "term"))
									       return 4;
									  else
										   if(d.type != "unknow")
										      return 0; })
	    .transition()
	    .delay(1500)
	    .duration(750)
	    .style("opacity", "1.0");
	    									  
	//segnale alto tipologia splice sites		
	var triangle_up = box.append("g")
		.attr("id", "triangle_up")
		.attr("transform", "translate(" + margin_isoform.left + "," + margin_isoform.top/2 + ")");
										
	triangle_up.selectAll("path")
		.data(s_s)
		.enter().append("path")
		.attr("id", function(d, i) { return "up_" + d.id; })
		.attr("d", s_sy)
		.attr("fill", "none")
		.attr("stroke","black")
		.attr("stroke-width", "1px")
		.attr("visibility", function(d) { 
								//se lo splice site Ã¨ 'init' o 'term' non deve
								//aver un segnale di tipologia
								if((d.type == 'init') | (d.type == 'term'))
									return "hidden";
								else
									return "visible";})
		.style("opacity", "0.0")
		.attr("transform", function (d) {
							  //ruota il segnale in base alla tipologia
		                      if(d.type == 3)
							     return "translate(" + (x_scale(d.position) - 3) + ",-27)" + "rotate(-90)";
							  else
							  	 if(d.type == 5)
								 	return "translate(" + (x_scale(d.position) + 3) + ",-27)" + "rotate(90)"; })
	    .transition()
        .delay(1500)
        .duration(750)
        .style("opacity", "1.0");
    
    //contenitore segnale basso degli splice sites
    var triangle_down = box.append("g")
		.attr("id", "triangle_down")
		.attr("transform", "translate(" + margin_isoform.left + "," + margin_isoform.top/2 + ")");
											
	triangle_down.selectAll("path")
		.data(s_s)
		.enter().append("path")
		.attr("id", function(d, i) { return "down_" + d.id; })
		.attr("d", s_sy)
		.attr("fill", "none")
		.attr("stroke","black")
		.attr("stroke-width", "1px")
		.style("opacity", "0.0")
		.attr("visibility", function(d) { 
								if((d.type == 'init') | (d.type == 'term'))
									return "hidden";
								else
									return "visible";})
		.attr("transform", function (d) {
		                      if(d.type == 3)
							     return "translate(" + (x_scale(d.position) - 3) + ", 106)" + "rotate(-90)";
							  else
							     if(d.type == 5)
								    return "translate(" + (x_scale(d.position) + 3) + ", 106)" + "rotate(90)"; })
	    .transition()
        .delay(1500)
        .duration(750)
        .style("opacity", "1.0");
   		
	return splice_sites;
}


/* SEQUENCE_BOX
 * s_box -> contenitore della struttura genica
 * seq_info -> array contenente gli elementi di cui visualizzare 
 * 			   la sequenza
 * 
 * Visualizza le sequenze nucleotidiche degli elementi selezionati.
 */
function sequence_box(s_box, seq_info){
	
	//colori titolo e sequenze
	var color_title = function() { return d3.rgb("blue"); };
	var color_sequence = function() { return d3.rgb("black"); };
	
	//oggetto delle posizioni in base al numero di sequenze 
	//da visualizzare
	var position = {
		y_pos : 190,
		x_pos_ex : 150,
		x_pos_in : 150
	};
    
    if(flag_sequence == false){
    	s_box.append("text")
        	.attr("id", "title_sequence")
        	.attr("x", 0)
        	.attr("y", 30)
        	.style("font-family", "Arial, Helvetica, sans-serif")
        	.style("font-size", "20px")
        	.style("fill", color_title)
        	.text("Nucleic sequence:")
        	.attr("transform", "translate(" + margin_isoform.left + "," + position.y_pos + ")")
        	.style("opacity", "0.0")
        	.transition()
        	.duration(750)
        	.style("opacity","1.0");
        flag_sequence = true;
    }
    	
    //offset tra sequenze di esoni e introni in base alla presenza degli stessi
    if(seq_info.r_i != null)   	
		off_set_ex = seq_info.r_i.length * position.x_pos_ex;
	if(seq_info.i_i != null)
		var off_set_in = seq_info.i_i.length * position.x_pos_in;
	
	//box per le sequenze degli esoni
	var sequence_ex = s_box.append("g")
		.attr("id", "sequence_ex")
		.attr("transform", "translate(" + (margin_isoform.left * 20) + "," + position.y_pos + ")");
    
    //box per le sequenze degli introni
    var sequence_in = s_box.append("g")
        .attr("id", "sequence_in")
        .attr("transform", "translate(" + (off_set_ex + (margin_isoform.left * 20)) + "," + position.y_pos + ")");
        
    //sequenze esoni
    sequence_ex.selectAll("text")
    	.data(seq_info.r_i)
    	.enter().append("text")
    	.attr("id", function(d) { return "sequence_ex_" + d.id; })
        .attr("x", function (d, i) { 
        			//la sequenza da visualizza viene costruita concatenando le prime e le ultime
        			//quattro lettere ed inserendo dei caratteri di continuitÃ  nel mezzo.
        			//Viene utilizzata per calcolare la posizione del testo.
        			var seq = '';
        			var li = '- - - - -';
        			seq = seq.concat(d.sequence.slice(0,4).toUpperCase(), li,
        							 d.sequence.slice(d.sequence.length - 4,d.sequence.length).toUpperCase());
        			//calcolo della lunghezza della stringa in base al font
        			var canvas = document.createElement('canvas');
					var ctx = canvas.getContext("2d");
					ctx.font = "15px Arial";        
					var width_seq = ctx.measureText(seq).width;
        			return (i * width_seq); })
        .attr("y", 30)
        .style("font-size", "12px")
        .style("font-family", "Arial, Helvetica, sans-serif")
        .style("fill", color_sequence)
        .style("opacity", "0.0")
        .text(function(d) { 
        		//la sequenza da visualizza viene costruita concatenando le prime e le ultime
        		//quattro lettere ed inserendo dei caratteri di continuitÃ  nel mezzo
        		var seq = '';
        		var li = '- - - - -';
        		seq = seq.concat(d.sequence.slice(0,4).toUpperCase(), li,
        					     d.sequence.slice(d.sequence.length - 4,d.sequence.length).toUpperCase());
        		return seq; })
        .transition()
        .duration(750)
        .style("opacity","1.0");
    
    //sequenze introni
    //solo se gli introni appartengono alla selezione    
    if(seq_info.i_i != null)
        sequence_in.selectAll("text")
            .data(seq_info.i_i)
            .enter().append("text")
            .attr("id", function(d) { return "sequence_in_" + d.id; })
            .attr("x", function (d, i) {
            			
            			//la sequenza da visualizza viene costruita concatenando le prime e le ultime
        				//quattro lettere ed inserendo dei caratteri di continuitÃ  nel mezzo.
        				//Viene utilizzata per calcolare la posizione del testo.
            			var seq_in = d.prefix + d.suffix;
            			var seq = '';
        				var li = '- - - - -';
        				seq = seq.concat(seq_in.slice(0,4).toUpperCase(), li,
        								 seq_in.slice(seq_in.length - 4, seq_in.length).toUpperCase());
            			var canvas = document.createElement('canvas');
						var ctx = canvas.getContext("2d");
						ctx.font = "18px Arial";        
						var width_seq = ctx.measureText(seq).width;
        				return (i * width_seq); })
            .attr("y", 30)
            .style("font-size", "12px")
            .style("font-family", "Arial, Helvetica, sans-serif")
            .style("fill", color_sequence)
            .style("opacity", "0.0")
            .text(function(d) {
            		//la sequenza da visualizza viene costruita concatenando le prime e le ultime
        			//quattro lettere ed inserendo dei caratteri di continuitÃ  nel mezzo.
            		var seq_in = d.prefix + d.suffix;
            		var seq = '';
        			var li = '- - - - -';
        			seq = seq.concat(seq_in.slice(0,4).toUpperCase(), li,
        							 seq_in.slice(seq_in.length - 4, seq_in.length).toUpperCase()); 
            		return seq; })
            .transition()
        	.duration(750)
        	.style("opacity","1.0");        
}


/* SCALING_REGIONS
 * r -> regioni
 * 
 * Modifica le regioni in base alla loro dimensione (size = end - start). Aumenta
 * quelle minori di 50 e diminuisce quelle maggiori di 1500
 */
function scaling_regions(r){
	
	//calcolo delle dimensioni delle regioni
	for(i = 0; i < r.length - 1; i++){
		size_regions = r[i].end - r[i].start;
		
		//regioni troppo piccole (< 50 pixel)
		if(size_regions < 50){
			size_regions_scaled = size_regions * (80 / size_regions);
			r[i].end = r[i].end + size_regions_scaled;
			r[i + 1].start = r[i].end;
		}
		//regioni troppo grandi (> 1500 pixel)
		if(size_regions > 1500){
			size_regions_scaled = size_regions * (800 / size_regions);
			r[i].end = r[i].end - size_regions_scaled;
			r[i + 1].start = r[i].end;
		}	
	}
    return r;
}


/* CHANGE_GENE 
 * gene -> nome file JSON contenente la struttura dei dati
 * 
 * Permette di cambiare gene, rimuovendo la struttura disegnata e 
 * richiamando nuovamente la funzione "init" per disegnare la nuova
 * struttura.
 */
function change_gene(gene){
    
    //durata animazioni
    var d = 450;
    
    //rimozione di tutti i box SVG
    var g = d3.select("#isoform").selectAll("g");
    g.remove();
        
    //pulisce la finestra degli elementi selezionati
    remove_element_expande_box();
    
    //aggiorna il file json da cui estrarre i dati
    default_structure = gene;
    
    //reinizializza la struttura
    init();
    zoom_isoform.translate([0, 0]).scale(1);
    svg_isoform.transition()
    	.duration(d)
        .attr("transform", "translate(" + zoomListener.translate() + ")scale(" + zoomListener.scale() + ")");  
    flag_zoom = false;
    svg_isoform.on("mousedown.zoom", null);
	svg_isoform.on("mousemove.zoom", null);
	svg_isoform.on("dblclick.zoom", null);
	svg_isoform.on("touchstart.zoom", null);
	svg_isoform.on("wheel.zoom", null);
	svg_isoform.on("mousewheel.zoom", null);
	svg_isoform.on("MozMousePixelScroll.zoom", null); 
}


/* NAVIGATION_BAR
 * 
 * Modifica la navbar creata nel file index.html aggiungendo
 * le informazioni relative al gene selezionato.
 */
function navigation_bar(){
	
	var d = 450;
	
	//nome del gene
	var h_g = d3.select("#home_gene");
	h_g.text(string_gene + " gene structure");
	
	h_g.on("click", function(){ 
						//assegna al nome del gene le stesse funzioni del pulsante reset
						remove_element_expande_box();
						//riporta la struttura genica alle dimensioni originali
        				zoom_isoform.translate([0, 0]).scale(1);
        				svg_isoform.transition()
        					.duration(d)
        					.attr("transform", "translate(" + zoom_isoform.translate() + ")scale(" + zoom_isoform.scale() + ")");
						});
	
	//legge il file JSON di configurazione. Contiene la lista
	//dei file JSON
	d3.json("Json_file/config.json", function(error, list) {
		
		//aggiunge la lista selezionabile dei file JSON
		var dp_s = d3.select("#select_gene");
		dp_s.selectAll("li")
			.data(list.gene_structures)
			.enter().append("li")
			.append("a")
				.attr("href", "#")
	   			.text(function(d) { return d.name; })
	   			.on("click", function(d) { change_gene(d.name); });
	});
}

/* SETUP_INTERFACE
 * 
 * Inizializza le finestre di visualizzazione e chiama la funzione "init".
 */
function setup_interface(){
      
    //texture esoni alternative  
    pattern_exons();
    
    //oggetto per la posizione della finestra della struttura
    var pos_box = {
    	pos: "absolute",
    	left : "10px",
    	right : "10px",
    	top : "60px",
    	bottom : "10px"
    };
    svg_isoform = set_svg("isoform", width - width_isoform, height_isoform, pos_box); 
        
    init();   
    
    svg_expande = svg_expande_box();  
    
    legend_box();  
    buttons();                       
}


/* ORIGINAL_STRUCTURE
 * s -> struttura
 * type_structure -> tipologia della struttura (esone, introni o splice sites)
 * 
 * Ricalcola le strutture utilizzando i valori originali delle regioni.
 */
function original_structure(s, type_structure){
	
	var st;
	
	switch(type_structure){
		case 'exon':
		{
			st = exons_structure(exons, s, boundaries);
			break;	
		}
		case 'intron':
		{
			st = introns_structure(introns, s, boundaries);
			break;
		}
		case 'splice':
		{
			st = splice_sites_structure(s, boundaries);
		}
	}
	
	return st;
}

/* COPY_REGIONS
 * s -> struttura delle regioni da copiare
 * 
 * Copia il vettore delle regioni che poi sara modificato
 * per scalare le dimensioni degli elementi
 */
function copy_regions(s){
    
    var copy_reg = [];
    for(t = 0; t < s.length; t++)
        copy_reg.push({
            "start" : s[t].start,
            "end" : s[t].end,
            "sequence" : s[t].sequence,
            "type" : s[t].type,
            "alternative" : s[t].alternative,
            "coverage" : s[t].coverage,
            "last" : s[t].last,
            "id" : s[t].id    
        });
    
    return copy_reg;    
}

/* COPY_INFO_GENE
 * s -> struttura delle informazioni da copiare
 * 
 * Copia gli oggetti relativi alle informazione
 * sul gene.
 */
function copy_info_gene(s){
    
    var copy_info;
    copy_reg = {
    	"sequence_id" : s.sequence_id,
        "program_version" : s.program_version,
        "file_format_version" : s.file_format_version,
        "gene" : s.gene    
    };
    
    return copy_reg;    
}

/* FILE_INFORMATION
 * 
 * Riporta nella navbar le informazioni sul file JSON.
 */
function file_information(){
	
	var dp_i = d3.select("#info_gene");
	dp_i.selectAll("li").remove();
	dp_i.append("li")
		.style("font-size", "12px")
		.text(function() { return "sequence_id: " + original_info.sequence_id; });
	dp_i.append("li")
		.style("font-size", "12px")
	   	.text(function() { return "file_format_version: " + original_info.file_format_version; });
	dp_i.append("li")
		.style("font-size", "12px")
	   	.text(function() { return "program_version: " + original_info.program_version; });
}

/* INIT
 * 
 * Inizializza tutte le funzione per disegnare la struttura. 
 * Carica i dati dal file json relativo al gene selezionato.
 * Di default carica "ATP6AP1example2.json"
 */
function init(){
	
    var path_file = "Json_file/";
    //carica i dati contenuti nel file json e richiama le funzioni per disegnare la struttura
    //dell'isoforma
    d3.json(path_file.concat(default_structure), function(error, atp) {
	
	   if(error != null){
	   	  console.log(error);
	   	  console.log(error.response);
	   	  var error_string = "";
	   	  error_string = error_string.concat(error.responseURL, " ", error.statusText);
	   	  window.alert(error_string);
	   }
	   	  
	   isoform = atp[0];
	   
	   original_info = copy_info_gene(isoform);
	   
	   //copia dell'array originale delle regioni
	   original_regions = copy_regions(isoform.regions);
	   //regioni
	   x = isoform_range(isoform.regions);
	   regions = scaling_regions(isoform.regions);
	   
	   //estrae il nome del gene
	   string_gene = original_info.gene;
	
	   //navbar
	   navigation_bar();	   
	   file_information();
	   
	   //boundaries
	   boundaries = isoform.boundaries;

	   //esoni
	   exons = isoform.exons;

	   //introni
	   introns = isoform.introns;
	
	   //esoni, introni e boundaries ricostruiti
	   exons_restruct = exons_structure(exons, regions, boundaries);
	   introns_restruct = introns_structure(introns, regions, boundaries);
	   s_s_restruct = splice_site_structure(boundaries, regions);
	  
	   //disegna la struttura
	   line_i = draw_introns(svg_isoform, introns_restruct, x);
	   rect = draw_exons(svg_isoform, exons_restruct, x);
	   s_s = draw_splice_sites(svg_isoform, s_s_restruct, x);	  	
    });
} 
</script>
<body ng-app="starter" ng-controller="ListCtrl">
    <ion-header-bar class="top">
      <h1 class="title">Items</h1>
      <button class="button button-icon ion-plus" ng-click="addItem()">
      </button>
    </ion-header-bar>
</body>
<ion-content>
  <ion-list>
    <ion-item ng-repeat="item in items">
      {{item.name}}
    </ion-item>
  </ion-list>
</ion-content>

